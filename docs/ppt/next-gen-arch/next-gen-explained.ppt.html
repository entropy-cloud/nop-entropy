<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>可逆计算：一种基于坐标系与变化代数的软件构造范式</title>
    <!-- 使用CDN确保可靠性与版本锁定 -->
    <link rel="stylesheet" href="../assets/css/all.min.css">
    <script src="../assets/js/html2pdf.bundle.min.js"></script>
	<script src="../assets/js/mermaid.min.js"></script>
	<script src="../assets/js/lightbox.js"></script>

    <style>
        :root {
            --color-primary: #2563eb;
            --color-primary-dark: #1e40af;
            --color-secondary: #059669;
            --color-warning: #d97706;
            --color-danger: #dc2626;
            --color-text-dark: #1f2937;
            --color-text-light: #4b5563;
            --color-bg-main: #f8fafc;
            --color-bg-slide: #ffffff;
            --color-border: #e5e7eb;
            --color-code-bg: #f8fafc;
            --font-main: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            --font-code: 'Fira Code', 'Cascadia Code', 'SF Mono', monospace;
            --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
            --font-size-base: 1.6rem;
            --line-height-base: 1.7;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: var(--font-main);
            background: linear-gradient(135deg, #f4f6f9 0%, #eef2f7 100%);
            color: var(--color-text-dark);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
            line-height: var(--line-height-base);
        }

        #presentation-container {
            width: 95vw; height: 95vh; max-width: 1400px;
            background: var(--color-bg-slide); border-radius: 20px; box-shadow: var(--shadow-lg);
            display: flex; flex-direction: column; overflow: hidden; position: relative;
            padding-bottom: 70px; border: 1px solid rgba(0,0,0,0.05);
        }

        .slides-viewport { flex-grow: 1; position: relative; overflow: hidden; }

        .slide {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            padding: 50px 70px;
            opacity: 0; visibility: hidden;
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            transform: translateY(15px) scale(0.99);
            display: flex; flex-direction: column; justify-content: flex-start;
            overflow-y: auto; background-color: var(--color-bg-slide);
        }
        .slide.center-content { justify-content: center; text-align: center; }
        .slide.active { opacity: 1; visibility: visible; transform: translateY(0) scale(1); z-index: 1; }

        h1, h2, h3 { font-weight: 700; line-height: 1.3; }
        h1 { font-size: 3.2rem; margin-bottom: 1.5rem; text-align: center; color: var(--color-text-dark); }
        h2 { font-size: 2.8rem; color: var(--color-text-dark); border-bottom: 4px solid var(--color-primary); padding-bottom: 1rem; margin-bottom: 2rem; font-weight: 600; }
        h3 { font-size: 2rem; color: var(--color-primary); margin-bottom: 1.5rem; }
        h3 .subtitle { font-size: 1.5rem; color: var(--color-text-light); font-weight: 400; display: block; margin-top: 0.5rem; }
        p, li { font-size: var(--font-size-base); color: var(--color-text-light); margin-bottom: 1.5rem; }
        strong { color: var(--color-primary); font-weight: 600; }
        ul { padding-left: 2rem; }
        
        .four-column { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; margin-top: 2rem; }
        .four-column .item { background: #f9fafb; padding: 25px; border-radius: 15px; text-align: center; border: 2px solid var(--color-border); }
        .four-column .item i { font-size: 2.5rem; color: var(--color-primary); margin-bottom: 1rem; }
        .four-column .item h4 { font-size: 1.4rem; margin-bottom: 1rem; color: var(--color-text-dark); }
        .four-column .item p { font-size: 1.1rem; line-height: 1.6; }

        #progress-bar { position: absolute; top: 0; left: 0; height: 5px; background: linear-gradient(90deg, var(--color-primary), var(--color-secondary)); width: 0%; transition: width 0.4s ease; z-index: 10; }
        .controls { position: absolute; bottom: 20px; right: 25px; display: flex; gap: 12px; z-index: 10; }
        .btn { background: linear-gradient(135deg, var(--color-primary), var(--color-primary-dark)); color: white; border: none; padding: 12px 20px; border-radius: 12px; cursor: pointer; font-weight: 600; display: flex; align-items: center; gap: 8px; transition: all 0.3s ease; box-shadow: var(--shadow-md); font-size: 0.9rem; }
        .btn:hover:not(:disabled) { transform: translateY(-3px) scale(1.05); box-shadow: var(--shadow-lg); }
        .btn:disabled { background: linear-gradient(135deg, #9ca3af, #6b7280); cursor: not-allowed; }
        #pdf-btn { background: linear-gradient(135deg, var(--color-secondary), #047857); }
        #slide-counter { position: absolute; bottom: 25px; left: 25px; background: rgba(255, 255, 255, 0.9); padding: 12px 18px; border-radius: 12px; font-size: 1rem; font-weight: 600; z-index: 10; box-shadow: var(--shadow-md); }
        
        .title-slide .subtitle { font-size: 1.6rem; color: var(--color-text-light); font-weight: 400; max-width: 80%; margin: 1rem auto 0; }
        .title-slide .eng-subtitle { font-size: 1.2rem; color: #9ca3af; font-family: var(--font-code); margin-top: 2rem; }
        
        .comparison-layout { display: grid; grid-template-columns: 1fr auto 1fr; gap: 2rem; align-items: stretch; margin: 2rem 0; }
        .comparison-left, .comparison-right { padding: 2rem; border-radius: 16px; border: 3px solid; display: flex; flex-direction: column; }
        .comparison-left { background: #fef2f2; border-color: var(--color-danger); }
        .comparison-right { background: #f0fdf4; border-color: var(--color-secondary); }
        .comparison-divider { display: flex; align-items: center; justify-content: center; font-size: 2.5rem; font-weight: 900; color: var(--color-primary); }
        .comparison-left h4, .comparison-right h4 { text-align:center; font-size: 1.6rem; margin-bottom: 1.5rem; display:flex; align-items:center; justify-content:center; gap: 10px; }
        .comparison-left h4 { color: var(--color-danger); }
        .comparison-right h4 { color: var(--color-secondary); }
        .comparison-left p, .comparison-right p, .comparison-left li, .comparison-right li { font-size: 1.3rem; }

        .three-column { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 25px; margin-top: 2rem; }
        .three-column .item { background: #f9fafb; padding: 30px; border-radius: 15px; text-align: center; border: 2px solid var(--color-border); }
        .three-column .item i { font-size: 2.5rem; color: var(--color-primary); margin-bottom: 1rem; }
        .three-column .item h4 { font-size: 1.5rem; margin-bottom: 1rem; color: var(--color-text-dark); }
        .three-column .item p { font-size: 1.2rem; line-height: 1.6; }

        .icon-list { list-style: none; padding: 0; margin: 2rem 0; }
        .icon-list li { display: flex; align-items: flex-start; gap: 20px; font-size: 1.5rem; margin-bottom: 1.5rem; }
        .icon-list i { font-size: 1.8rem; color: var(--color-primary); margin-top: 5px; }

        .code-block { background-color: var(--color-code-bg); padding: 1.2em; border-radius: 8px; font-family: var(--font-code); font-size: 1rem; border: 1px solid var(--color-border); margin: 1rem 0; }
        
        .highlight-box { background: #eff6ff; border-left: 6px solid var(--color-primary); padding: 1.5rem 2rem; margin: 2rem 0; border-radius: 0 12px 12px 0; }
        .highlight-box p { font-size: 1.6rem; margin: 0; font-weight: 500; }
        .warning-box { background: #fffbeb; border-left: 6px solid var(--color-warning); padding: 1.5rem 2rem; margin: 2rem 0; border-radius: 0 12px 12px 0; }
        .warning-box p, .warning-box h4 { margin: 0; color: #92400e; }
        .warning-box h4 { font-size: 1.5rem; font-weight: 600; margin-bottom: 0.5rem; }
        .warning-box p { font-size: 1.3rem; }
        .quote { background: #faf5ff; border-left: 6px solid #a855f7; padding: 30px; margin: 2.5rem auto; border-radius: 0 12px 12px 0; font-style: italic; color: #581c87; max-width: 85%; text-align: center; }
        .quote p { font-size: 1.8rem; margin: 0; }
        .formula { background: var(--color-code-bg); padding: 25px; border-radius: 15px; text-align: center; font-family: var(--font-code); font-size: 2.2rem; font-weight: bold; color: var(--color-primary); margin: 2.5rem auto; border: 2px solid var(--color-border); }
        .formula .note { font-size: 1rem; color: var(--color-text-light); margin-top: 1rem; font-weight: normal; font-family: var(--font-main); }
        .formula .note strong { color: var(--color-primary-dark); }

        .detail-note { background: #f8f9fa; border: 1px solid #e9ecef; padding: 1rem 1.5rem; border-radius: 8px; margin-top: 1.5rem; font-size: 1.2rem; line-height: 1.6; color: var(--color-text-light); }
        .detail-note strong { color: var(--color-text-dark); }
        .detail-note code { font-family: var(--font-code); background: #e9ecef; padding: 2px 6px; border-radius: 4px; font-size: 1.1rem;}

        .mermaid-container { background-color: #fff; padding: 1.5rem; border-radius: 12px; border: 1px solid var(--color-border); margin: 2rem 0; overflow: auto; display: flex; justify-content: center; }
		
		.mermaid {
            display: flex;
            justify-content: center;
            width: 100%;
        }

        .comparison-table { width: 100%; border-collapse: separate; border-spacing: 0; margin: 2rem 0; border-radius: 16px; overflow: hidden; box-shadow: var(--shadow-md); border: 1px solid var(--color-border); }
        .comparison-table th, .comparison-table td { padding: 1.2rem; text-align: left; border-bottom: 1px solid var(--color-border); }
        .comparison-table th { background: linear-gradient(135deg, var(--color-primary), var(--color-primary-dark)); color: white; font-weight: 700; font-size: 1.1rem; }
        .comparison-table tr:last-child td { border-bottom: none; }
        .comparison-table tr:nth-child(even) { background-color: #f9fafb; }
        .comparison-table td:nth-child(2) { font-weight: 600; color: var(--color-primary); }

        .debug-flow { display: flex; align-items: flex-start; justify-content: space-between; gap: 1rem; margin-top: 1rem; width: 100%; }
        .debug-col { flex: 1; display: flex; flex-direction: column; align-items: center; }
        .debug-col.output { flex: 1.3; }
        .debug-col h4 { margin-bottom: 1rem; text-align: center; color: var(--color-text-dark); font-size: 1.2rem; border: none; padding: 0; }
        .source-file { background-color: var(--color-bg-slide); border: 1px solid var(--color-border); padding: 0.8em 1em; border-radius: 6px; font-family: var(--font-code); font-size: 0.9rem; width: 100%; margin-bottom: 1rem; box-shadow: var(--shadow-md); }
        .source-file .path { font-weight: 600; color: var(--color-secondary); margin-bottom: 0.5rem; display: block; }
        .process-arrow { font-size: 4rem; color: var(--color-primary); text-align: center; margin-top: 5rem; }
        .process-arrow p { font-size: 1rem; font-weight: 600; margin-top: 0.5rem; color: var(--color-primary-dark); }
        .dump-comment-v3 { color: #64748b; font-style: normal; }
		
		@media print {
            body { background: #fff !important; height: auto; overflow: visible; display: block; }
            .controls, #progress-bar, #slide-counter { display: none !important; }
            #presentation-container { display: block; width: 100%; height: auto; box-shadow: none; border: none; padding: 0; }
            .slides-viewport { overflow: visible; height: auto; }
            .slide { display: flex !important; opacity: 1 !important; visibility: visible !important; transform: none !important; position: relative; page-break-after: always; page-break-inside: avoid; width: 100%; height: auto; aspect-ratio: 16 / 9; border: 1px solid #ddd; margin-bottom: 20px; box-shadow: none; border-radius: 0; overflow: hidden; }
            .slide:last-of-type { page-break-after: avoid; }
            svg * { animation-play-state: paused !important; }
        }
        
        .pdf-page-container { width: 100%; height: auto; background: white; color: black; box-shadow: none; }
        .pdf-slide { position: relative !important; opacity: 1 !important; visibility: visible !important; transform: none !important; height: auto !important; width: 100%; background: white; border: 1px solid #eeeeee; padding: 40px 50px; box-shadow: none; margin-bottom: 0; overflow: hidden; page-break-after: always; break-inside: avoid; aspect-ratio: 16 / 12; }
        .pdf-slide:last-of-type { page-break-after: avoid; }

    </style>
</head>
<body>

<div id="presentation-container">
    <div id="progress-bar"></div>
    <div id="slide-counter">1 / 25</div>

    <div class="slides-viewport">

<!-- Slide 1: Title (Revised) -->
<section class="slide active title-slide center-content">
    <h1>可逆计算的理论内核</h1>
    <p class="subtitle">不止是"更好的差量合并"：深入坐标系与变化代数</p>
    <p class="eng-subtitle">Beyond "Better Diff/Merge": A Deep Dive into Coordinates and an Algebra of Change</p>
</section>

<!-- Slide 2: Definition & Origin (Revised with precise definition) -->
<section class="slide">
    <h2>🎯 定义、渊源与背景</h2>
    <div class="highlight-box" style="margin-top:1rem;">
        <p><strong>定义</strong>：可逆计算 (Reversible Computation)，是一套关于“变化”的软件构造理论，其两大基石是<strong>可逆差量 (Reversible Delta)</strong> 与 <strong>可逆变换 (Reversible Transformation)</strong>。</p>
    </div>
    <div class="warning-box">
        <h4><i class="fa-solid fa-triangle-exclamation"></i> 术语澄清</h4>
        <p>它与物理学中的“热力学可逆计算(Thermodynamic Reversible Computing)”在语义上完全不同。</p>
    </div>
    <div class="detail-note" style="margin-top:1rem;">
        <strong>理论渊源</strong>
        <ul>
            <li style="font-size:1.2rem; margin-bottom:0.5rem"><strong>独立原创</strong>：核心思想诞生于 <strong>2007 年</strong>，是一次基于物理/几何世界观的跨界、独立探索，早于后来在业界广泛传播的 DOP/FOP 实践。</li>
            <li style="font-size:1.2rem; margin-bottom:0.5rem"><strong>殊途同归</strong>：它并非派生自 DOP、BX 等国际前沿研究，但与它们在目标上高度一致，形成了并行的探索路线，共同指向“变化组合”这一核心问题。</li>
        </ul>
    </div>
</section>

<!-- Slide 3: The "Why" (Revised to address core objection) -->
<section class="slide">
    <h2>🤔 为什么需要这次讨论？</h2>
    <div class="warning-box">
        <h4>认知锚定：我们习惯用旧地图理解新大陆</h4>
        <p>在接触本范式时，我们常无意识地将其等同于已知的技术，从而错失其真正的创新之处。</p>
    </div>
    <div class="detail-note">
        <strong>常见的认知锚定点：</strong>
        <ul>
            <li style="font-size:1.2rem; margin-bottom:0.5rem">这不就是 Git / Kustomize / Docker Overlay 吗？</li>
            <li style="font-size:1.2rem; margin-bottom:0.5rem">这不就是 GraphQL extend / Spring 扩展点机制吗？</li>
            <li style="font-size:1.2rem; margin-bottom:0.5rem">“可逆”不就是指“可逆运行”吗？那种理论没什么实用价值。</li>
        </ul>
        <p style="font-size:1.2rem; margin-top:1rem;">本次解析的目标：系统性地澄清这些误解，直达理论内核。</p>
    </div>
</section>

<!-- Slide 4: Reuse Revolution (Refined based on feedback) -->
<section class="slide">
    <h2>范式革命：复用原理的根本转变</h2>
    <div class="comparison-layout">
        <div class="comparison-left">
            <h4><i class="fa-solid fa-object-group"></i> 传统复用：求交集 ∩</h4>
            <p>基于继承、组合与预设扩展点，只能复用“相同”的部分，偏细粒度。</p>
            <pre class="code-block">X = A ⊕ B ⊕ C
Y = A ⊕ B ⊕ D
// 只能复用 A ⊕ B</pre>
        </div>
        <div class="comparison-divider">VS</div>
        <div class="comparison-right">
            <h4><i class="fa-solid fa-calculator"></i> 可逆计算：求差量 Δ</h4>
            <p>引入逆元，将已有成果作为整体基底进行粗粒度复用，只需描述其差异（支持横向迁移/向上抽象）。</p>
            <pre class="code-block">X = A ⊕ B ⊕ C
Y = X ⊕ (-C ⊕ D)
// 复用了整个 X</pre>
        </div>
    </div>
    <div class="quote" style="margin-top:1rem;">
        <p>从“相同才能复用”到“用差量复用相似”，实现从细粒度到粗粒度的飞跃。</p>
    </div>
</section>

<!-- Slide 5: Core Principles (NEW) -->
<section class="slide">
    <h2>理论的四项核心原则</h2>
    <p style="text-align:center;margin:0">变化的几何-代数基础</p>
    <div class="four-column" style="margin-top:1.5rem;">
        <div class="item">
            <i class="fa-solid fa-crosshairs"></i>
            <h4>坐标系原则</h4>
            <p>任何软件制品都可视为一个“坐标空间”，其内部元素拥有稳定、可演化的唯一坐标。</p>
        </div>
        <div class="item">
            <i class="fa-solid fa-calculator"></i>
            <h4>叠加运算原则</h4>
            <p>在同一坐标系下，所有变化(Δ)依据明确规则（顺序、冲突解算）进行组合，形成可确定的叠加运算(⊕)。</p>
        </div>
        <div class="item">
            <i class="fa-solid fa-right-left"></i>
            <h4>同态传递原则</h4>
            <p>模型间的生成器(G)是“表象变换”，在适用域内，可将源模型的变化(ΔX)自动投影为目标模型的变化(ΔY)。</p>
        </div>
        <div class="item">
            <i class="fa-solid fa-layer-group"></i>
            <h4>S-N-V分层准则</h4>
            <p>任何模型构造过程都可分解为S(结构合并)、N(领域规范化)、V(全局验证)三阶段，保证过程确定且可调试。</p>
        </div>
    </div>
</section>

<!-- Slide 6: vs. Git/Patch -->
<section class="slide">
    <h2>这与Git Diff/JSON Patch有何不同？</h2>
    <div class="comparison-layout">
        <div class="comparison-left">
            <h4><i class="fa-solid fa-list-ol"></i> 传统差量 (动作指令)</h4>
            <pre class="code-block" style="font-size:0.9rem;">[{ "op": "replace", "path": "/a/b/c", "value": 42 }]</pre>
            <ul>
                <li><strong>载体分裂</strong>：对象和变化是两种东西。</li>
                <li><strong>高阶困难</strong>：对“变化本身”再应用变化很复杂。</li>
            </ul>
        </div>
        <div class="comparison-divider">VS</div>
        <div class="comparison-right">
            <h4><i class="fa-solid fa-tree"></i> 可逆计算 (统一代数)</h4>
            <pre class="code-block" style="font-size:0.9rem;">&lt;a&gt;&lt;b&gt;&lt;c x:override="replace"&gt;42&lt;/c&gt;&lt;/b&gt;&lt;/a&gt;</pre>
            <ul>
                <li><strong>统一载体</strong>：全量与差量共享同一种结构。</li>
                <li><strong>自然闭包</strong>：高阶组合（差量的差量）自然成立。</li>
            </ul>
        </div>
    </div>
    <div class="detail-note"><strong>核心区别：</strong>它不是一种新的“补丁语言”，而是基于<strong>统一代数结构</strong>对“变化”本身的重构，使其具备了可组合性。</div>
</section>


<!-- Slide 7: Three Meanings of Reversibility (Director's Cut) -->
<section class="slide">
    <h2>“可逆”到底是什么？三大核心内涵</h2>
    <p style="text-align:center;">可逆计算中的可逆并不是指程序的“逆向执行”，而是贯穿代数、变换和构造过程的系统性能力。</p>
    <div class="three-column" style="margin-top:2rem;">
         <div class="item">
            <i class="fa-solid fa-calculator"></i>
            <h4>1. 代数可逆性 (可求解)</h4>
            <p><strong>核心</strong>：引入“逆元”和“减法”，使构造方程 <code>App = Base ⊕ Δ</code> 能够自由移项求解。<br><strong>效果</strong>：我们既能计算出两个版本间的差量 (求<code>Δ</code>)，也能从最终结果中撤销一个变化，还原出原始基础 (求<code>Base</code>)。</p>
        </div>
        <div class="item">
            <i class="fa-solid fa-right-left"></i>
            <h4>2. 变换可逆性 (可往返)</h4>
           <p><strong>核心</strong>：建立高保真的“往返(Round-trip)”变换，确保信息在不同表示间不失真。<br><strong>效果</strong>：实现 <code>DSL ⇔ Excel</code>、<code>模型 ⇔ 可视化UI</code> 等不同形态间的无缝编辑和变化传递。</p>
        </div>
        <div class="item">
            <i class="fa-solid fa-clock-rotate-left"></i>
            <h4>3. 过程可逆性 (可修正)</h4>
            <p><strong>核心</strong>：打破线性的构造时间轴，允许用一个“未来”的差量Δ，去修正一个“过去”已发布的系统。<br><strong>效果</strong>：获得一枚“后悔药”，无需重编译上游，即可“空降”补丁，精准修正其内部任意部分。</p>
        </div>
    </div>
</section>

<!-- Slide 8: S-N-V Principle Explained (Rebuilt) -->
<section class="slide">
    <h2>原则详解：S-N-V 分层准则</h2>
    <p style="text-align:center;">它解决了通用合并中的核心矛盾：<strong>结构操作</strong> vs. <strong>语义约束</strong>。</p>
    
    <div class="three-column" style="margin-top:1.5rem;">
        <div class="item" style="border-color: var(--color-primary); background: #eff6ff;"><i class="fa-solid fa-layer-group"></i><h4>S: 结构合并</h4><p>按坐标合并树，只关心结构，不关心语义。此过程幂等且有序（一般不要求可交换）。</p></div>
        <div class="item"><i class="fa-solid fa-gears"></i><h4>N: 规范化</h4><p>解糖、补默认值，进行领域特定的、幂等的语义转换。保留溯源信息，便于调试。</p></div>
        <div class="item" style="border-color: var(--color-secondary); background: #f0fdf4;"><i class="fa-solid fa-circle-check"></i><h4>V: 验证</h4><p>在最后一步统一检查类型和约束，确保最终模型的全局合法性。</p></div>
    </div>

    <div class="highlight-box" style="margin-top:1.5rem;">
        <p><strong>核心洞察：“虚时间”的存在。</strong>允许在S之后暂时语义不合法，待N归一与V观测才收敛为合法。由此彻底解耦“结构摆放”与“意义检查”，实现通用、可预测的合并。</p>
    </div>
</section>

<!-- Slide 9: Language as Coordinate System (Final Elegant Version) -->
<section class="slide">
    <h2>原则详解：语言即坐标系</h2>

    <p style="font-size: 1.2rem; font-style: italic; text-align: center; margin-top: 1rem; margin-bottom: 2rem;">
        “语言的边界就是我们世界的边界。” — 维特根斯坦
    </p>

    <p style="text-align:center; margin-top:0;">
        一个定义良好的语言，其<strong>结构树（AST/模型树）</strong>天然形成一个内禀的、具有明确语义的坐标系。
    </p>

    <div class="comparison-layout" style="margin-top:2rem; align-items: stretch;">
        <div class="comparison-left">
            <h4><i class="fa-solid fa-compass"></i> 固化坐标 (如行号)</h4>
            <p>当代码重构时，坐标易失效，导致基于它的修改（如<code>patch</code>）变得脆弱。</p>
        </div>
        <div class="comparison-divider">→</div>
        <div class="comparison-right">
            <h4><i class="fa-solid fa-location-crosshairs"></i> 活动坐标 (内禀于结构树)</h4>
            <p>坐标随结构演化而平滑调整，使得<strong>精确、可定位的“点-扰动”式修改</strong>具备鲁棒性。</p>
        </div>
    </div>
    
    <div class="highlight-box" style="margin-top:1.5rem; border-left-color: var(--color-primary-dark);">
         <p style="font-size:1.4rem; font-weight: 600; margin:0; text-align:center;">
            结论：统一且可演化的坐标系，是可逆计算能够成立的关键前提之一，是理论公理而非实现细节。
        </p>
    </div>
</section>

<!-- Slide 10: DSL Atlas - Compact & Balanced Layout -->
<section class="slide">
    <h2>推论：从“单一模型”到“DSL图册 (Atlas)”</h2>
    <p style="text-align:center;">我们不追求一个“超级语言”，而是构建一个多DSL协同的框架：各司其职，重叠处用映射对齐。</p>

    <div class="comparison-layout" style="align-items:center; margin-top:0; gap:1.5rem;">
        <div class="comparison-left" style="padding: 1.5rem 2rem;">
            <h4 style="margin-bottom:1rem;"><i class="fa-solid fa-cube"></i> 传统MDD</h4>
            <div class="mermaid-container" style="padding:0.8rem; margin:0;">
                <div class="mermaid">graph TD; A["庞大的Super-DSL"] --> B["信息过载<br/>难以演化"];</div>
            </div>
        </div>
        <div class="comparison-divider">→</div>
        <div class="comparison-right" style="padding: 1.5rem 2rem;">
            <h4 style="margin-bottom:1rem;"><i class="fa-solid fa-sitemap"></i> DSL图册</h4>
            <div class="mermaid-container" style="padding:0.8rem; margin:0;">
                <div class="mermaid">
 graph LR
                    D1["DSL1 数据<br/>(XORM)"]
                    D2["DSL2 服务<br/>(GraphQL)"]
                    D3["DSL3 界面<br/>(XView)"]
                    D1 <-- "G12/G21" --> D2
                    D2 <-- "G23/G32" --> D3
                </div>
            </div>
            <p style="margin-top:0.8rem; margin-bottom:0; font-size:1.1rem;">通过生成器(G)连接多个专注的DSL，实现变化在不同“图表”间传递。</p>
        </div>
    </div>
    
    <div class="detail-note" style="margin-top:0rem; padding: 1.2rem 1.5rem;">
        <div style="display: flex; align-items: flex-start; gap: 1rem;">
            <i class="fa-solid fa-book-atlas" style="color:var(--color-primary); font-size: 2.2rem; margin-top: 5px;"></i>
            <div>
                <strong>类比：</strong>这与微分几何中的“图册(Atlas)”思想类似，它由多个“图表(Chart)”通过“变换映射(Transition Map)”粘合而成。<br>
				<strong>原则：</strong>一域一DSL，重叠处有映射契约，数量宜少不宜多。<br>
				     </div>
        </div>
    </div>
</section>

<!-- Slide 11: Homomorphic Principle - Layout Corrected -->
<section class="slide">
    <h2>同态传递原则</h2>
    <p style="text-align:center;">Generator (G) 是不同坐标系(DSL)间的“表象变换”。</p>
    
    <div class="formula" style="margin-top:2.5rem;">
        G(X ⊕ ΔX) ≡ G(X) ⊕ ΔY
        <div class="note">其中 <strong>ΔY</strong> 是由G根据源差量 <strong>ΔX</strong> 导出的目标差量</div>
    </div>

    <p style="font-size:1.6rem; max-width:85%; margin: 2rem auto; text-align:center;">
        这意味着，<strong>变化(Δ)</strong>可以在不同的语言/模型之间自动传递和投影。这是实现跨DSL协同的数学基石。
    </p>

    <div class="detail-note" style="margin-top:2rem; text-align: left;">
        <strong>举例：</strong>在数据模型(X)中为一个字段增加“显示名”的差量(ΔX)，经生成器(G)投影后，会自动在界面模型(G(X))中产生一个更新表格列标题的目标差量(ΔY)。
    </div>
</section>
        
<!-- Slide 12: Generator vs. Template Engine (Compact List Style) -->
<section class="slide">
    <h2>关键澄清：Generator不是传统模板引擎</h2>
    <div class="comparison-layout">
        <div class="comparison-left">
            <h4><i class="fa-solid fa-code"></i> 传统模板引擎 (文本替换)</h4>
            <ul style="padding-left: 1.5rem;">
                <li style="font-size: 1.2rem; margin-bottom: 0.8rem;"><strong>单向生成</strong>：模型 → 文本，无法回溯。</li>
                <li style="font-size: 1.2rem; margin-bottom: 0.8rem;"><strong>过程黑盒</strong>：生成逻辑与结果混杂，不可追溯。</li>
                <li style="font-size: 1.2rem; margin-bottom: 0.8rem;"><strong>高度脆弱</strong>：基于文本匹配，重构即失效。</li>
                <li style="font-size: 1.2rem; margin-bottom: 0;"><strong>全量覆盖</strong>：无“变化”概念，每次都重新生成。</li>
            </ul>
        </div>
        <div class="comparison-divider">VS</div>
        <div class="comparison-right">
            <h4><i class="fa-solid fa-arrows-rotate"></i> 表象变换 (结构映射)</h4>
            <ul style="padding-left: 1.5rem;">
                <li style="font-size: 1.2rem; margin-bottom: 0.8rem;"><strong>双向可逆</strong>：支持高保真往返 (Round-trip)。</li>
                <li style="font-size: 1.2rem; margin-bottom: 0.8rem;"><strong>过程白盒</strong>：生成过程可追溯、可调试 (via _dump)。</li>
                <li style="font-size: 1.2rem; margin-bottom: 0.8rem;"><strong>结构鲁棒</strong>：基于稳定的坐标系，不受格式变动影响。</li>
                <li style="font-size: 1.2rem; margin-bottom: 0;"><strong>变化传递</strong>：能将源模型的变化(ΔX)投影为目标模型变化(ΔY)。</li>
            </ul>
        </div>
    </div>
    <div class="highlight-box"><p>将Generator视为模板引擎，是典型的“认知锚定”，会错失其<strong>可往返(变换可逆性)</strong>和<strong>变化传递(同态)</strong>的核心本质。</p></div>
</section>

<!-- Slide 13: Universal Decomposition Principle -->
<section class="slide">
    <h2>推论：普适分解原理</h2>
    <p style="text-align:center">任何复杂的软件构造问题 Y = G(X) 都可以被分解。</p>
    <div class="formula" style="font-size:1.5rem;margin-top:0">Y = G(X)  ≡ G0(X0) ⊕ ΔY </div>
    <div class="comparison-layout" style="margin-top:0rem;">
        <div class="comparison-left" style="background:#eef2ff; border-color:#6366f1; text-align:center;">
            <h4 style="color:#4338ca;"><i class="fa-solid fa-arrows-left-right"></i> 横向分解 (多视角投影)</h4>
            <p>将一个复杂模型，分解为多个简单领域（数据、业务、界面）的<strong>并列组合</strong>。</p>
        </div>
        <div class="comparison-divider">⊕</div>
        <div class="comparison-right" style="background:#f0f9ff; border-color:#3b82f6; text-align:center;">
            <h4 style="color:#1d4ed8;"><i class="fa-solid fa-layer-group"></i> 纵向分解 (递归抽象)</h4>
            <p>将一个底层模型，通过层层生成和差量修正，<strong>递归地构建</strong>出高层模型。</p>
        </div>
    </div>
     <div class="detail-note">例如：一个“用户查询页面”可被<strong>横向分解</strong>为数据(ORM)、API(GraphQL)、视图(View)三个模型。同时，视图模型又是由API模型<strong>纵向分解</strong>(生成)而来。</div>
</section>

<!-- Slide 14: Self-Consistency (Loader as Generator) - Ultra-Concise -->
<section class="slide">
    <h2>推论：自洽性 (Loader as Generator)</h2>
    
    <p style="text-align:center; font-size: 1.5rem; margin-bottom: 1.5rem;">
        一个“可能世界”的模型由一组分散的路径定义： <strong> Possible Path = BasePath + DeltaPath </strong>
    </p>

 <div class="comparison-layout" style="align-items:stretch;margin-top:0">
        <div class="comparison-left">
            <h4><i class="fa-solid fa-box"></i> 传统: L(A + B)</h4>
            <p>先组合路径，再送入黑盒加载器，规则不透明。</p>
            <pre class="code-block" style="text-align:center; font-size:1.1rem; margin-top: auto;">Loader(BasePath + DeltaPath)</pre>
        </div>
        <div class="comparison-divider">→</div>
        <div class="comparison-right">
            <h4><i class="fa-solid fa-shapes"></i> 可逆计算: L(A) ⊕ L(B)</h4>
            <p>先独立加载为模型，再通过统一的代数运算(⊕)组合。</p>
            <pre class="code-block" style="text-align:center; font-size:1.2rem; font-weight:bold; color:var(--color-primary); margin-top: auto;">Loader(BasePath) ⊕ Loader(DeltaPath)</pre>
        </div>
    </div>
        
<div class="detail-note" style="margin-top:0rem;">
    <strong>同态的必然性：</strong> 加载器(L)被定义为一个<strong>同态生成器(G)</strong>，负责将“路径空间(+, ∅)”映射至“模型空间(⊕, 0)”。
    <br>
    这一映射确保了平台自身的构造过程也严格遵循核心代数法则，实现理论自洽。
</div>
</section>


<!-- [OPTIMIZED ORDER] Slide 18 is moved here -->
<section class="slide">
    <h2 style="text-align:center">从理论到现实：工程化基石</h2>
    <p style="text-align:center">这不是魔法，而是一套严谨的工程体系。</p>
    <ul class="icon-list" style="margin-top:2rem; max-width: 85%; margin-left: auto; margin-right: auto;">
        <li><i class="fa-solid fa-crosshairs fa-fw"></i> <div><strong>统一坐标系</strong>：提供唯一、稳定的“身份证”，并定义其重命名/移动演化规则。</div></li>
        <li><i class="fa-solid fa-layer-group fa-fw"></i> <div><strong>叠加运算 ⊕</strong>：定义非交换顺序规则与冲突解算策略，保证合并的确定性。</div></li>
        <li><i class="fa-solid fa-rocket fa-fw"></i> <div><strong>AOT预合并</strong>：在构建期完成合并，保证运行时原生性能。</div></li>
        <li><i class="fa-solid fa-magnifying-glass-location fa-fw"></i> <div><strong>_dump溯源</strong>：每个最终结果都能追溯其来源，极大提升调试效率。</div></li>
        <li><i class="fa-solid fa-plug fa-fw"></i> <div><strong>渐进式采纳</strong>：通过Loader替换，非侵入式地与现有技术栈（如Spring）集成。</div></li>
    </ul>
</section>

<!-- [OPTIMIZED ORDER] Slide 16 is moved here & Title Updated -->
<section class="slide">
    <h2>核心数据结构：XNode与局域化元信息</h2>
    <p style="text-align:center">XNode是Nop平台统一的内存结构模型，它原生支持携带“局域元信息”。</p>
    <div class="three-column">
        <div class="item">
            <i class="fa-solid fa-paperclip"></i>
            <h4>机制：命名空间即扩展</h4>
            <p>通过XML命名空间（如<code>meta:</code>、<code>loc:</code>），任何节点都可以“就地携带”不属于其核心模型的扩展属性。</p>
        </div>
        <div class="item">
            <i class="fa-solid fa-box-open"></i>
            <h4>优势：信息自包含</h4>
            <p>溯源信息、合并决策、临时状态等元数据与差量(Δ)一起参与⊕运算，无需复杂的外部<code>sourcemap</code>链。</p>
        </div>
        <div class="item">
            <i class="fa-solid fa-shield-halved"></i>
            <h4>治理：安全可控</h4>
            <p>通过命名空间注册表、发布期剥离策略来管理这些扩展属性，确保核心模型的纯净与安全。</p>
        </div>
    </div>
</section>

<!-- [OPTIMIZED ORDER] Slide 15 is moved here -->
<section class="slide">
    <h2>告别猜谜：可追溯的构造过程</h2>
    <p style="text-align:center; font-size:1.4rem; color:var(--color-text-light); margin-top:-1.5rem; margin-bottom: 2rem;">
        模型合并的最终结果会自动输出到_dump目录，并精确记录每个属性的来源位置。
    </p>

    <div class="debug-flow" style="margin-top:0">
        <div class="debug-col">
            <h4>1. 输入源 (分散定义)</h4>
            <div class="source-file">
                <span class="path">/config.xml</span>
                <code>&lt;bean id="svc" class="app.MySvc"&gt;
&lt;prop name="timeout" value="<strong style="color:var(--color-danger);">3000</strong>"/&gt;
&lt;/bean&gt;</code>
            </div>
            <div class="source-file">
                <span class="path">/_delta/default/config.xml</span>
                <code>&lt;bean id="svc"&gt;
&lt;prop name="timeout" value="<strong style="color:var(--color-secondary);">5000</strong>"/&gt;
&lt;/bean&gt;</code>
            </div>
        </div>

        <div class="debug-col" style="flex: 0.4;">
            <div class="process-arrow" style="margin-top: 5rem;">
                <i class="fa-solid fa-arrow-right-long"></i>
                <p>代数合并 (⊕)</p>
            </div>
        </div>

        <div class="debug-col output">
            <h4>2. 可追溯的输出 (_dump)</h4>
            <style>
                .dump-comment-v3 { color: #059669; font-style: normal; }
                .dump-comment-v3 strong { color: #047857; font-weight: 600; }
                .dump-comment-v3 .loc-info { color: #6b7280; font-size: 0.9em; font-style: italic; }
            </style>
            <pre class="code-block" style="margin:0; width:100%; font-size: 0.85rem; line-height:1.6;"><code>&lt;beans&gt;
&lt;bean id="svc" class="app.MySvc"&gt;
<span class="dump-comment-v3">&lt;!-- @value <strong>LOC:[2:3:0]@/_delta/default/config.xml</strong>--&gt;</span>
&lt;prop name="timeout" value="<strong style="color:var(--color-secondary);">5000</strong>"/&gt;
&lt;/bean&gt;
&lt;/beans&gt;</code></pre>
        </div>
    </div>
    
    <div class="highlight-box" style="margin-top:2.5rem;">
       <p><strong>调试不再靠猜：</strong> 面对异常的<code>timeout</code>值，根源定位不再是“大海捞针”。_dump信息就是一张精准的地图，直接将问题锁定在 `_delta/default/config.xml`。</p>
    </div>
</section>

<!-- Slide 17: Excel Example (Final Compact Layout Version) -->
<section class="slide">
    <h2>应用范例：赋能现有Excel资产</h2>
    <p style="text-align:center; font-size:1.3rem; color:var(--color-text-light); margin-top:-1.5rem; margin-bottom: 1.5rem;">
        一个展示模型与编辑器组合的经典案例
    </p>

    <!-- 1. 价值呈现：对比 -->
    <div class="comparison-layout" style="margin-bottom: 2rem;">
        <div class="comparison-left">
            <h4><i class="fa-solid fa-puzzle-piece"></i> 传统方案</h4>
            <p style="font-size:1.2rem;">导入/导出模式破坏原生性，无法利旧（资产需重做），学习成本高。</p>
        </div>
        <div class="comparison-divider">VS</div>
        <div class="comparison-right">
            <h4><i class="fa-solid fa-wand-magic-sparkles"></i> 可逆计算方案</h4>
            <p style="font-size:1.2rem;">通过非侵入式扩展，任何现有Excel都能直接成为专业报表模板。</p>
        </div>
    </div>
    
    <!-- 2. 原理揭示：水平化布局 -->
    <div class="highlight-box" style="margin-top:0; padding: 25px;">
        <div class="comparison-layout" style="gap: 1.5rem; margin:0; align-items:flex-start;">
            <!-- 左侧：模型组合 -->
            <div style="text-align:center; flex:1;">
                <h4 style="font-size:1.4rem; color:var(--color-text-dark); margin-bottom:1rem; border:none; padding:0;">1. 模型组合</h4>
                <code style="font-size:1.3rem; color:var(--color-primary-dark); display:block;">报表模板 = Excel ⊕ 报表扩展Δ</code>
            </div>
            
            <div class="comparison-divider" style="font-size: 2rem;">
                <i class="fa-solid fa-arrow-right"></i>
            </div>

            <!-- 右侧：编辑器组合 -->
            <div style="text-align:center; flex:1.3;">
                <h4 style="font-size:1.4rem; color:var(--color-text-dark); margin-bottom:1rem; border:none; padding:0;">2. 编辑器组合</h4>
                <code style="font-size:1.3rem; color:var(--color-primary-dark); display:block;">Editor(报表模板) = Editor(Excel) ⊕ Editor(Δ)</code>
            </div>
        </div>

        <div class="detail-note" style="margin-top:1.5rem; padding: 1rem 1.5rem; background:#fff; border: 1px solid var(--color-border); font-size:1.15rem; line-height:1.7; text-align: center;">
            <i class="fa-solid fa-lightbulb" style="color:var(--color-warning);"></i>
            <strong>主动的线性化设计</strong>：通过严格<strong>局域化</strong>差量(Δ)的传播，才在架构上实现了这种可组合性。
        </div>
    </div>
</section>

<!-- Slide 19: Quantitative Validation (Revised) -->
<section class="slide">
    <h2>如何衡量成功？量化验证指标</h2>
    <p style="text-align:center">理论的价值需要通过可度量的工程效果来验证。</p>
    <table class="comparison-table">
        <thead>
            <tr>
                <th>验证维度</th>
                <th>核心指标</th>
                <th>建议目标 / 验收阈值*</th>
                <th>对照基线</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><i class="fa-solid fa-right-left"></i> 表象可逆性</td>
                <td>往返保真度 (语义等价率)</td>
                <td>> 95%</td>
                <td>传统导入/导出</td>
            </tr>
            <tr>
                <td><i class="fa-solid fa-shuffle"></i> 变化传递</td>
                <td>同态传递成功率</td>
                <td>> 90%</td>
                <td>手写代码同步</td>
            </tr>
            <tr>
                <td><i class="fa-solid fa-rotate-left"></i> 过程可逆性</td>
                <td>升级回放干预率</td>
                <td>< 20%</td>
                <td>Git分支合并冲突率</td>
            </tr>
            <tr>
                <td><i class="fa-solid fa-crosshairs"></i> 坐标系鲁棒性</td>
                <td>重构后坐标命中率</td>
                <td>> 98%</td>
                <td>基于文本的重构工具</td>
            </tr>
        </tbody>
    </table>
    <div class="detail-note" style="font-size:1rem;">*具体数值依赖于基准场景和对照方法的选择，需通过实际PoC项目进行验证和校准。</div>
</section>
        
<!-- Slide 20: Applicability & Unifying Perspective (IMPROVED) -->
<section class="slide">
    <h2>广泛适用性：从应用领域到统一范式</h2>
    <p style="text-align:center;">本范式不仅指导Nop平台的构建，更能为业界已有的、基于差量思想的创新实践提供统一的理论解释。</p>
    
    <style>
        .two-col-applicability {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2.5rem;
            margin-top: 1.5rem;
        }
        .applicability-col {
            background-color: #f8fafc;
            border: 1px solid var(--color-border);
            border-radius: 16px;
            padding: 1.5rem 2rem;
        }
        .applicability-col h4 {
            font-size: 1.6rem;
            border-bottom: 2px solid var(--color-primary);
            padding-bottom: 0.8rem;
            margin-bottom: 1.5rem;
        }
        .applicability-col .icon-list { margin-top: 0; }
        .applicability-col .icon-list li { font-size: 1.3rem; gap: 15px; }
        .applicability-col .icon-list i { font-size: 1.5rem; }
        .applicability-col .formula-like {
            font-family: var(--font-code);
            color: var(--color-secondary);
            font-size: 1.1rem;
            display: block;
            margin-top: 0.25rem;
        }
    </style>

    <div class="two-col-applicability">
        <div class="applicability-col">
            <h4><i class="fa-solid fa-rocket"></i> Nop平台的直接应用领域</h4>
            <ul class="icon-list">
                <li>
                    <i class="fa-solid fa-cubes-stacked fa-fw"></i>
                    <div>
                        <p><strong>软件产品线</strong></p>
                        <span class="formula-like">Base ⊕ Δ_Industry ⊕ Δ_Customer</span>
                    </div>
                </li>
                <li>
                    <i class="fa-solid fa-server fa-fw"></i>
                    <div>
                        <p><strong>IaC与云原生配置</strong></p>
                        <span class="formula-like">BaseYAML ⊕ Δ_Env ⊕ Δ_App</span>
                    </div>
                </li>
                <li>
                    <i class="fa-solid fa-table-list fa-fw"></i>
                    <div>
                        <p><strong>数据/报表流水线</strong></p>
                        <span class="formula-like">StdModel ⊕ Δ_Source ⊕ Δ_Rule</span>
                    </div>
                </li>
            </ul>
        </div>
        <div class="applicability-col">
            <h4><i class="fa-solid fa-magnifying-glass-chart"></i> 统一解释的现有实践</h4>
             <ul class="icon-list">
                <li>
                    <i class="fa-brands fa-docker fa-fw"></i>
                    <div>
                        <p><strong>Docker 镜像</strong></p>
                        <span class="formula-like">BaseImage ⊕ Layer₁ ⊕ Layer₂</span>
                    </div>
                </li>
                <li>
                    <i class="fa-solid fa-code-merge fa-fw"></i>
                    <div>
                        <p><strong>Kustomize/Helm</strong></p>
                        <span class="formula-like">BaseManifest ⊕ Overlay ⊕ Patch</span>
                    </div>
                </li>
                <li>
                    <i class="fa-brands fa-react fa-fw"></i>
                    <div>
                        <p><strong>虚拟DOM (React)</strong></p>
                        <span class="formula-like">OldVNode ⊕ Diff(Δ) → NewVNode</span>
                    </div>
                </li>
            </ul>
        </div>
    </div>

    <div class="highlight-box" style="margin-top: 2rem;">
        <p>这些看似不同的技术，其核心都是对某个“基础”进行“差量”叠加。可逆计算为这一普适模式提供了形式化的语言和工程化的框架。</p>
    </div>
</section>

<!-- Slide 21: Common Objections (Hybrid Optimized Version - Corrected HTML) -->
<section class="slide">
    <h2>常见疑虑与回应</h2>

    <div class="three-column" style="margin-top:2.5rem;">
        <div class="item">
            <i class="fa-solid fa-box-archive"></i>
            <h4>"只是营销包装"</h4>
            <p><strong>回应：</strong>核心创新在于将软件构造抽象到<strong>多DSL的结构空间</strong>，并以<strong>统一坐标系</strong>与<strong>叠加运算(⊕)</strong>为基础，配合<strong>同态传递</strong>与<strong>S-N-V</strong>分层，形成一整套自洽的<strong>工程化实现</strong>，而非对现有工具的拼装。</p>
        </div>
        <div class="item">
            <i class="fa-solid fa-brain"></i>
            <h4>"过于复杂，学习成本高"</h4>
            <p><strong>回应：</strong>复杂性被框架内化。使用者可通过具体实践（如Excel模型和报表）无感地获得其收益，并通过<strong>渐进式采纳</strong>（模型化改造）逐步深化应用，而非要求一次性全盘掌握。</p>
        </div>
        <div class="item" style="border-color:var(--color-primary); background: #eff6ff;">
            <i class="fa-solid fa-wand-magic-sparkles"></i>
            <h4>"是银弹吗？边界何在？"</h4>
            <p><strong>回应：</strong>它不是银弹，而是为“可扩展性”问题提供了<strong>通用解</strong>。其边界在于<strong>选择</strong>：我们多大程度上愿意将逻辑“升维”到描述式的模型中，决定了我们能多大程度上享受其红利。</p>
        </div>
    </div>
    
    <div class="highlight-box" style="margin-top:3rem;">
        <p style="text-align:center;"><i class="fa-solid fa-map-location-dot" style="margin-right:10px;"></i>可逆计算提供了一张更强大的“地图”。能否到达目的地，取决于我们是否选择并坚持走“模型驱动”这条路。</p>
    </div>
</section>

<!-- Slide 22: Conclusion (Final Optimized Version based on feedback) -->
<section class="slide">
    <h2 style="text-align:center;">结论：可逆计算的系统性蓝图</h2>
    <p style="text-align:center; font-size: 2rem; margin-bottom: 1.5rem;">可逆计算 = 变化的代数学 + 软件的几何学</p>
    
    <ul class="icon-list" style="margin-top:0rem; max-width: 95%; margin-left: auto; margin-right: auto;">
        <li style="margin-bottom: 1rem; align-items: flex-start;">
            <i class="fa-solid fa-crosshairs fa-fw" style="margin-top: 2px;"></i>
            <div style="font-size: 1.3rem; line-height: 1.6;"><strong>坐标系原则（几何）：</strong>为模型元素提供稳定、可演化的唯一坐标，是变化可定位与可传递的前提。</div>
        </li>
        <li style="margin-bottom: 1rem; align-items: flex-start;">
            <i class="fa-solid fa-calculator fa-fw" style="margin-top: 2px;"></i>
            <div style="font-size: 1.3rem; line-height: 1.6;"><strong>叠加运算原则（代数）：</strong>在同一坐标系下定义 ⊕（结合、一般不交换），并引入逆元，使“复用从求交集转为求差量”，支持撤销与迁移。</div>
        </li>
        <li style="margin-bottom: 1rem; align-items: flex-start;">
            <i class="fa-solid fa-sitemap fa-fw" style="margin-top: 2px;"></i>
            <div style="font-size: 1.3rem; line-height: 1.6;"><strong>DSL 图册（协同）：</strong>以生成器 G 作为“表象变换”，满足同态传递，令变化在多 DSL 之间自动投影与对齐。</div>
        </li>
        <li style="margin-bottom: 1rem; align-items: flex-start;">
            <i class="fa-solid fa-layer-group fa-fw" style="margin-top: 2px;"></i>
            <div style="font-size: 1.3rem; line-height: 1.6;"><strong>S-N-V 分层（过程）：</strong>S 结构合并、N 规范化、V 验证，解耦结构与语义，确保可调试、可回放、可验证。</div>
        </li>
        <li style="margin-bottom: 1rem; align-items: flex-start;">
            <i class="fa-solid fa-infinity fa-fw" style="margin-top: 2px;"></i>
            <div style="font-size: 1.3rem; line-height: 1.6;"><strong>自洽性（自反）：</strong>平台自身各环节（Loader/Generator/Editor）均遵循同态与 ⊕ 法则，实现从加载到编辑到生成的一致性。</div>
        </li>
    </ul>

    <div class="formula" style="font-size:1rem; margin: 0rem auto 0; padding: 10px 20px; width: fit-content;">
        <code>G(X ⊕ ΔX) ≡ G(X) ⊕ ΔY</code>
        <span style="margin: 0 1.5rem; font-weight: 100; color: var(--color-border);">|</span>
        <code>L(A + B) ≡ L(A) ⊕ L(B)</code>
        <div class="note" style="margin-top: 1rem;">同态小结：变化在跨 DSL（G）与平台加载（L）两层均可传递与复合，形成可验证的一致性。</div>
    </div>
</section>

<!-- [NEW SLIDE] Worldview Shift -->
<section class="slide">
    <h2>世界观的转换：从“拼装对象”到“叠加变化”</h2>
    <p style="text-align:center; font-size:1.4rem; color:var(--color-text-light); margin-top:-1.5rem; margin-bottom: 2rem;">
        我们思考软件构造的出发点发生了根本性转变。
    </p>

    <div class="comparison-layout" style="margin-top:0">
        <div class="comparison-left">
            <h4><i class="fa-solid fa-cubes-stacked"></i> 传统世界观：对象本体论</h4>
            <ul class="icon-list" style="margin-top:0.5rem; padding-left:0;">
                <li style="font-size: 1.3rem; margin-bottom: 1rem; gap:15px;">
                    <i class="fa-solid fa-atom fa-fw"></i>
                    <div><strong>基本单元</strong>：对象、组件、模块是世界的基本“粒子”。</div>
                </li>
                <li style="font-size: 1.3rem; margin-bottom: 1rem; gap:15px;">
                    <i class="fa-solid fa-gears fa-fw"></i>
                    <div><strong>构造方式</strong>：通过“组装”和“侵入式修改”来构建系统。</div>
                </li>
                <li style="font-size: 1.3rem; margin-bottom: 1rem; gap:15px;">
                    <i class="fa-solid fa-magnifying-glass fa-fw"></i>
                    <div><strong>关注焦点</strong>：单个组件的内部状态及其之间的显式交互。</div>
                </li>
            </ul>
        </div>

        <div class="comparison-divider">→</div>

        <div class="comparison-right">
            <h4><i class="fa-solid fa-map-location-dot"></i> 新世界观：结构-变化二元论</h4>
            <ul class="icon-list" style="margin-top:0.5rem; padding-left:0;">
                <li style="font-size: 1.3rem; margin-bottom: 1rem; gap:15px;">
                    <i class="fa-solid fa-crosshairs fa-fw"></i>
                    <div><strong>基本单元</strong>：一个稳定的“结构坐标系”和作用于其上的“变化(Δ)”。</div>
                </li>
                <li style="font-size: 1.3rem; margin-bottom: 1rem; gap:15px;">
                    <i class="fa-solid fa-layer-group fa-fw"></i>
                    <div><strong>构造方式</strong>：通过“叠加”和“非侵入式投影”来生成系统。</div>
                </li>
                <li style="font-size: 1.3rem; margin-bottom: 1rem; gap:15px;">
                    <i class="fa-solid fa-wave-square fa-fw"></i>
                    <div><strong>关注焦点</strong>：作为背景的坐标系如何演化，以及变化(Δ)如何组合与传递。</div>
                </li>
            </ul>
        </div>
    </div>
    
    <div class="highlight-box" style="margin-top:0rem;">
       <p style="text-align:center; font-size: 1.6rem; font-weight:600;">核心转变：思考的起点从“世界由什么构成？” 转变 为“在哪个坐标系下，发生了什么变化？”</p>
    </div>
</section>

<!-- Slide 23: Final Punchline & CTA -->
<section class="slide center-content">
    <div class="quote" style="max-width:90%; padding: 40px;">
        <p style="font-size:2rem; line-height:1.6;">
            <strong>下一代低代码/无代码平台的架构基石</strong><br><br>
            将软件工程从“手工组合对象”的时代，<br>带向“代数化组合变化”的时代。
        </p>
    </div>
    <div class="warning-box" style="margin-top:2rem; text-align:left;">
        <h4><i class="fa-solid fa-bullhorn"></i> 行动召唤 (Call to Action)</h4>
        <p>理论的价值在于实践。建议从一个具体场景（如Excel报表）开始PoC，用量化指标证明其价值，让可逆计算从概念走向现实。</p>
    </div>
</section>

<!-- SLIDE 24: Q&A -->
<section class="slide center-content">
    <h1>Q & A</h1>
    <p class="subtitle">感谢聆听！</p>
</section>
		
<!-- SLIDE 25: BACKUP - Relationship with Existing Theories -->
<section class="slide" >
    <h2>与既有理论的关系定位</h2>
    <div class="mermaid-container" style="margin-top:0">
        <div class="mermaid">
graph TD
    subgraph framework [可逆计算统一框架]
        RC[可逆差量计算]
    end
    subgraph practices [既有分散实践]
        DOP[Delta-Oriented<br/>Programming]
        FOP[Feature-Oriented<br/>Programming]
        BX[Bidirectional<br/>Transformations]
        SPL[Software Product<br/>Lines]
        MDD[Model-Driven<br/>Development]
        Overlay[Overlay<br/>Technologies]
    end
    RC -->|统一结构层代数| DOP
    RC -->|统一结构层代数| FOP
    RC -->|统一结构层代数| SPL
    RC -->|统一结构层代数| Overlay
    RC -->|形式化定律| BX
    RC -->|变化代数协同| MDD
    style RC fill:#e1f5fe,stroke:#1976d2,stroke-width:4px
        </div>
    </div>
    <div class="detail-note" style="margin-top:0rem;">
    <strong>核心区别：</strong>可逆计算并非技术包装，而是将分散的“差量思想”公理化，为模型驱动开发(MDD)补上了最关键的“变化代数”与“多模型协同”的缺失维度。
    </div>
</section>

    </div>

    <!-- Controls -->
        <div class="controls">
            <button class="btn" id="home-btn" title="First Slide"><i class="fa-solid fa-home"></i></button>
            <button class="btn" id="prev-btn" title="Previous"><i class="fa-solid fa-arrow-left"></i></button>
            <button class="btn" id="next-btn" title="Next"><i class="fa-solid fa-arrow-right"></i></button>
            <button class="btn" id="fullscreen-btn" title="Fullscreen"><i class="fa-solid fa-expand"></i></button>
            <button class="btn" id="print-btn" title="Print"><i class="fa-solid fa-print"></i></button>
            <button class="btn" id="pdf-btn" title="Export to PDF"><i class="fa-solid fa-file-pdf"></i></button>
        </div>
</div>

   <script>
	// Mermaid图表配置和初始化
    mermaid.initialize({
        startOnLoad: true,
        theme: 'default',
        securityLevel: 'loose',
        fontFamily: 'var(--font-main)',
        flowchart: {
            useMaxWidth: false,
            htmlLabels: true,
            curve: 'basis'
        }
    });
	
    document.addEventListener('DOMContentLoaded', () => {
        const container = document.getElementById('presentation-container');
        const allSlides = document.querySelectorAll('.slide');
        const homeBtn = document.getElementById('home-btn');
        const prevBtn = document.getElementById('prev-btn');
        const nextBtn = document.getElementById('next-btn');
        const fullscreenBtn = document.getElementById('fullscreen-btn');
        const printBtn = document.getElementById('print-btn');
        const pdfBtn = document.getElementById('pdf-btn');
        const slideCounter = document.getElementById('slide-counter');
        const progressBar = document.getElementById('progress-bar');
        
        let currentSlide = 0;
        const totalSlides = allSlides.length;

        function showSlide(index, skipHashUpdate = false) {
            if (index < 0 || index >= totalSlides) return;
            allSlides.forEach((slide, i) => slide.classList.toggle('active', i === index));
            currentSlide = index;
            updateControls();
            if (!skipHashUpdate) {
                updateHash(index);
            }
        }
        function updateControls() {
            slideCounter.textContent = `${currentSlide + 1} / ${totalSlides}`;
            progressBar.style.width = `${((currentSlide + 1) / totalSlides) * 100}%`;
            prevBtn.disabled = currentSlide === 0;
            nextBtn.disabled = currentSlide === totalSlides - 1;
        }
        function nextSlide() { showSlide(currentSlide + 1); }
        function prevSlide() { showSlide(currentSlide - 1); }
        function goToFirstSlide() { showSlide(0); }
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                container.requestFullscreen().catch(err => alert(`Cannot enter fullscreen mode: ${err.message}`));
            } else {
                document.exitFullscreen();
            }
        }
        function updateHash(index) {
            const hash = `#slide-${index + 1}`;
            if (location.hash !== hash) {
                history.pushState(null, null, hash);
            }
        }
        function parseHashToIndex() {
            const h = location.hash;
            const m = h.match(/slide-(\d+)/i);
            if (m) {
                const idx = parseInt(m[1], 10) - 1;
                if (!isNaN(idx) && idx >= 0 && idx < totalSlides) {
                    return idx;
                }
            }
            return null;
        }

        function printPresentation() {
            window.print();
        }

        async function prepareForPdf() {
            const pdfContainer = document.createElement('div');
            pdfContainer.className = 'pdf-page-container';
            allSlides.forEach(slide => {
                const clone = slide.cloneNode(true);
                clone.classList.remove('active');
                clone.classList.add('pdf-slide');
				
				// 删除所有图片元素
				const images = clone.querySelectorAll('img');
				images.forEach(img => img.remove());
		
                pdfContainer.appendChild(clone);
            });
		
		
            document.body.appendChild(pdfContainer);
            return pdfContainer;
        }
        
        function exportToPDF() {
            console.log('Starting PDF export...');
            const originalButtonContent = pdfBtn.innerHTML;
            pdfBtn.innerHTML = '<i class="fa-solid fa-spinner fa-spin"></i> Generating...';
            pdfBtn.disabled = true;
            
            prepareForPdf().then(pdfContainer => {
                const options = {
                    margin: 0,
                    filename: 'nop-platform-presentation.pdf',
                    image: { type: 'jpeg', quality: 0.98 },
                    html2canvas: { scale: 2, useCORS: true, allowTaint:true, letterRendering: true },
                    jsPDF: { unit: 'in', format: 'letter', orientation: 'landscape' },
                    pagebreak: { mode: ['css'] }
                };

                html2pdf().set(options).from(pdfContainer).save().then(() => {
                    console.log('PDF export successful!');
                    document.body.removeChild(pdfContainer);
                    pdfBtn.innerHTML = originalButtonContent;
                    pdfBtn.disabled = false;
                }).catch(err => {
                    console.error('PDF export failed:', err);
                    document.body.removeChild(pdfContainer);
                    pdfBtn.innerHTML = originalButtonContent;
                    pdfBtn.disabled = false;
                    alert('PDF export failed. Check the console for details.');
                });
            });
        }

        homeBtn.addEventListener('click', goToFirstSlide);
        nextBtn.addEventListener('click', nextSlide);
        prevBtn.addEventListener('click', prevSlide);
        fullscreenBtn.addEventListener('click', toggleFullscreen);
        printBtn.addEventListener('click', printPresentation);
        pdfBtn.addEventListener('click', exportToPDF);

        document.addEventListener('keydown', (e) => {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
            if (e.key === 'ArrowRight' || e.key === ' ' || e.key === 'PageDown') { e.preventDefault(); nextSlide(); }
            if (e.key === 'ArrowLeft' || e.key === 'PageUp') { e.preventDefault(); prevSlide(); }
            if (e.key === 'Home') { e.preventDefault(); goToFirstSlide(); }
            if (e.key === 'End') { e.preventDefault(); showSlide(totalSlides - 1); }
        });

        let touchStartX = 0;
        container.addEventListener('touchstart', e => { touchStartX = e.changedTouches[0].screenX; }, { passive: true });
        container.addEventListener('touchend', e => {
            const touchEndX = e.changedTouches[0].screenX;
            if (touchStartX - touchEndX > 50) nextSlide();
            if (touchEndX - touchStartX > 50) prevSlide();
        });

        window.addEventListener('popstate', () => {
            const idx = parseHashToIndex();
            if (idx !== null && idx !== currentSlide) {
                showSlide(idx, true);
            }
        });

        const initialIndexFromHash = parseHashToIndex();
        if (initialIndexFromHash !== null) {
            showSlide(initialIndexFromHash, true);
        } else {
            showSlide(0);
        }
		
		setTimeout(()=>{
		  window.enableContentLightboxForSelector && window.enableContentLightboxForSelector('.mermaid svg, .column img,.slide svg')
		}, 1000);
    });
    </script>

</body>
</html>