# DDD 概念澄清：那些教程不会告诉你的事

## 引言

领域驱动设计（DDD）是 Eric Evans 在 2003 年提出的一套软件设计方法。二十年来，它被广泛讨论，也被广泛误解。多数教程会给你一份模式清单——实体、值对象、聚合根、限界上下文——然后告诉你每个模式的定义和用法。但这种"模式清单"式的理解往往停留在表面，导致实践中反复出现同样的困惑。

本文试图澄清几个常被忽视的核心问题。这些问题不是"DDD 怎么用"，而是"DDD 为什么是这样的"，以及"DDD 没有告诉我们什么"。

---

## 一、DDD 到底在解决什么问题

大多数介绍会说 DDD 是为了"应对复杂业务"。这没错，但太笼统了。

DDD 真正试图解决的问题可以更精确地表述：**业务逻辑本质上与技术无关，但我们的代码总是把业务逻辑和技术实现搅在一起，导致业务逻辑难以理解、难以修改、难以复用。**

想想你见过的代码。一个"下单"操作，本来是一个清晰的业务概念，但在实现中可能散落在 Controller 里拼装参数、Service 里管理事务、DAO 里写 SQL、消息队列里发事件……业务规则被技术实现的脚手架淹没了。当业务专家说"下单时要检查信用额度"，你需要在三四个文件中翻找才能搞清楚这个规则到底在哪里。

DDD 的各种模式——统一语言、限界上下文、聚合根、六边形架构——**本质上都在服务于同一个目标：构建一个技术中立的、纯粹用业务概念表达业务逻辑的代码结构。**

统一语言确保代码中的命名直接对应业务概念，同时也为开发者与领域专家之间的协作提供了共同的基础设施——它既是代码的命名规范，也是团队沟通的共同词汇表。但统一语言的意义不止于命名约定。**它是知识提炼（knowledge crunching）的过程和产物。** 语言中的每个词汇、每个关系都承载着团队对领域的当前最佳理解。比如"退款"和"冲正"可能在项目早期被当作同一个概念，经过与领域专家的反复讨论后才被识别为两个本质不同的概念——这不是给同一个东西换个名字，而是领域结构本身在认知深化中发生了变化。**发现正确的领域语言往往比用领域语言写代码困难得多，而这个发现过程正是 DDD 最核心的活动。**

限界上下文划分了不同业务概念的适用范围。六边形架构将数据库、Web 框架等技术细节推到外围，让领域模型不依赖任何具体技术。聚合根则在领域内部划定了概念的组织单元。

理解了这个根本目标，很多设计决策就变得清晰了：**如果一个设计选择让你的代码更纯粹地用业务概念表达业务逻辑，它就是值得优先考虑的；如果它引入了技术概念来污染业务表达，它就是需要审视的。**

---

## 二、限界上下文：你看到的不只是对象，还有空间

限界上下文是 DDD 战略设计中最重要的概念，但很多人对它的理解仅限于"同一个词在不同上下文中含义不同"——比如"商品"在商品目录中和在物流中含义不同。这个理解是对的，但只是故事的一半。

语言边界和空间划分是同一件事的两个面。多数人熟悉语言边界这一面，但没有充分认识到空间划分所带来的设计方法上的转变。

在没有限界上下文概念之前，我们怎么设计系统？我们先设计一大堆对象（用户、订单、商品、库存……），然后费力地梳理它们之间的关系。所有对象都在同一个平面上，我们只关注"物体"，不关注"空间"。这就像把所有家具堆在一个大房间里，然后试图通过重新摆放家具来解决拥挤的问题。

限界上下文改变了设计的顺序：**先建墙，再摆家具。** 先划分空间——哪些概念属于交易，哪些属于物流，哪些属于支付——然后在每个空间内部独立设计。每个空间有自己的规则、自己的语言、自己的模型。空间之间通过明确定义的接口通信。

这个顺序的转变意味着：**复杂性不再是通过在同一个空间里"更好地组织"来应对的，而是通过划分出多个独立的、简单的空间来消解的。**

---

## 三、聚合根的首要职责：比你以为的更丰富

如果你问十个 DDD 实践者"聚合根的核心职责是什么"，大概有九个会说"维护一致性边界"。

这个回答不算错，但它可能导致一种有害的设计倾向。

### 一致性边界之外的职责

当我们把"维护一致性"当作聚合根的唯一核心职责时，设计聚合根的第一个问题就变成了："哪些东西必须在同一个事务里修改？"然后我们根据事务需求来划定聚合的边界。

但请想一想，当你写下这段代码时：

```java
order.getCustomer().getCreditLimit()
```

这行代码首先是一句**领域语言的句子**——它用业务概念表达了"订单的客户的信用额度"这个业务事实。这个表达能力与一致性规则无关，它只是让一个业务概念在代码中自然存在。

这个导航路径之所以应该存在，不是为了编码便利，而是因为它反映了领域的内在结构——"订单有客户"、"客户有信用额度"是领域事实。这些事实构成的关联网络定义了领域模型的完整结构，使得领域中的每一个语义单元都可以通过路径被精确定位和访问。如果因为工程上的考虑（如防止跨聚合误修改）而从模型中移除这些导航路径，领域模型对领域结构的表达就是残缺的。正确的做法是保留表达能力，同时用基础设施手段（只读视图、架构约束）来解决工程问题——这两个关注点不应该被混为一谈。

这里需要澄清一个常见的混淆：这种导航能力不意味着 Customer 是 Order 聚合的一部分。聚合的大小由一致性边界决定，而领域对象之间的导航能力由 Manager/Repository 提供——这是两件不同的事。`order.getCustomer()` 背后的加载机制——是从本地数据库读取，还是从远程服务获取，还是从缓存命中——完全由基础设施层屏蔽，领域代码不知道也不应该知道。

有人可能担心透明导航的性能问题——比如遍历订单列表时逐条加载客户导致 N+1 查询。但这是基础设施层的工程问题，不是领域建模层面的架构约束。类似 GraphQL 的 batch loading 机制（如 NopORM 提供的预加载能力）可以将多个 `order.getCustomer()` 调用自动合并为一次批量查询，对领域代码完全透明。**领域模型不应该因为基础设施层的能力不足而妥协自身的表达力。** 这意味着基础设施层有责任提供这种透明化能力——如果当前使用的技术栈不支持，这是基础设施需要改进的方向，而不是领域模型需要妥协的理由。

Vaughn Vernon 在《实现领域驱动设计》中建议聚合之间通过 ID 而非对象引用关联，其动机包括性能和序列化的工程考量，也包括让聚合边界在代码中保持显式可见的认知考量。后者是一个真实的设计关切。但本文认为，边界可见性是基础设施层和工程纪律的职责——通过返回只读视图防止意外修改，通过架构测试规则检测不当的跨聚合依赖——而不应该以牺牲领域模型的表达力为代价，在领域对象的接口设计中强制体现。

聚合根通过它的属性和关联关系，定义了**哪些业务词汇存在，这些词汇如何合法地组合**。类名和属性名是词汇表，关联关系和方法签名定义了文法。聚合根是领域语言最直接、成本最低的载体——你不需要额外的基础设施，一个普通的 Java 类就能承载领域概念。

**如果我们把"领域语义表达"也视为聚合根的核心职责，设计的优先级就会发生变化：先确保聚合根能完整、自然地表达领域概念和关联关系，然后再考虑一致性边界怎么划。**

### 不变式与策略的混淆

"维护一致性"这个职责在实践中还引发了另一个问题：**大量可变的业务策略被错误地当作"不变式"硬编码进聚合根。**

考虑以下规则：

- "订单总价不能为负数"——这是结构性不变式，任何情况下都不应被违反。
- "VIP 客户下单可透支 10000 元"——这是市场策略，随时可能调整。
- "新用户首单享受八折优惠"——这是营销活动，生命周期短暂。

在"聚合根维护不变式"的心智模型下，开发者倾向于把这三种规则都塞进聚合根的方法中。结果聚合根迅速膨胀，充满了 `if-else` 分支，每次业务策略调整都要修改聚合根代码。

**聚合根真正需要守护的核心不变式其实很少**——通常只有"金额非负"、"状态机的合法迁移"这类结构性约束。大量的业务策略应该被外置到策略对象、规则引擎或流程编排中。

区分标准有两个互补的视角：**其一，如果这个规则违反了，数据在结构上就是损坏的（比如金额为负），那它是不变式；其二，如果这个规则定义了领域概念的本质特征（比如"订单必须至少有一个行项"——没有行项的订单在业务上不成立），那它也是不变式。** 反过来，如果违反规则后数据结构仍然合法、领域概念仍然成立，只是不符合当前的运营决策（比如透支额度），那它是策略，应该外置。

需要承认的是，**这条边界在具体上下文中可能是模糊的。** 比如"订单必须至少有一个行项"在某些业务场景中是绝对约束，但在支持"草稿订单"的系统中，空订单可能是合法的中间状态。判断一个规则是不变式还是策略，最终取决于你所在的限界上下文对该领域概念的定义——**同一个规则在不同的上下文中可能有不同的分类。** 上述区分标准是有用的启发式框架，但不应被当作机械可执行的规则。

---

## 四、领域依赖不是技术依赖

很多开发者对"依赖"有一种本能的警惕：跨越模块边界的依赖都是需要隔离的风险。这种警惕在面对技术依赖时是正确的——你不应该让业务代码依赖于特定的数据库表结构或特定的 HTTP 返回格式。

但当依赖的对象是**技术中立的领域概念**时，这种依赖不仅不是风险，反而是应该被鼓励的。

举个例子。假设一个报表需要显示"订单客户所在城市"，有两种做法：

**做法一：推送专用数据**
```java
// 调用方为报表准备专用 DTO
ReportInput input = new ReportInput();
input.setCity(order.getCustomer().getAddress().getCity());
reportEngine.generate(input);
```

**做法二：传入聚合根，让报表自己取**
```java
// 传入整个聚合根，报表通过领域表达式取数据
reportEngine.generate(order); 
// 报表模板中：${order.customer.address.city}
```

做法一看似"隔离了依赖"，但当需求变为"同时显示城市和省份"时，你需要修改 DTO 定义、修改数据组装逻辑、修改报表——三个地方的联动修改。

做法二中，报表依赖的是 `order.customer.address` 这个**领域结构**。当需求变化时，只需修改报表模板中的表达式。如果领域结构本身发生了变化（比如 `address` 被重构了），报表确实会受影响——**但它应该受影响**，因为领域事实变了。

> 以下讨论针对的是系统内部的消费场景——消费方与领域模型共享同一个领域语言和信任边界。对于对外 API 边界上的数据暴露控制，需要不同的机制（如元数据驱动的字段级权限和按需裁剪），但那同样不需要手写 DTO 映射。
>
> 这里的关键不是"传入了整个聚合根"，而是消费方使用 pull 模式，通过表达式直接声明自己需要什么（从稳定的、与特定使用目的无关的领域模型中拉取信息）。push 模式下，调用方需要提前知道消费方需要哪些字段，构造一个中间数据结构，再将数据复制过去。这个中间结构（DTO）的根本问题不在于"多了一层"，而在于它是同一份领域信息的冗余表示——领域对象中有一份，DTO 中复制了一份，映射代码不创造任何新的业务语义，只是在两种表示之间做机械转换。冗余必然带来同步成本：当领域结构变化时，DTO 要么跟着变（冗余表示的同步开销），要么不变（两份表示的语义漂移）。pull 模式下，消费方的表达式 `${order.customer.address.city}` 直接使用领域模型自身的结构作为唯一的寻址机制——没有冗余表示，没有数据复制，依赖关系集中在一处，通过延迟加载避免强耦合和性能损耗。

### 为什么 DTO 间接层往往适得其反

对上述做法二的一个常见反驳是："但如果领域模型重构了呢？比如从 Customer 中提取出 Address 值对象，导航路径就变了。"

这个担忧有两个问题。

**第一，DTO 在重构时改动量更大，不是更少。** 假设我们将 `customer.city` 重构为 `customer.address.city`：

- 直接依赖领域对象：消费方的访问路径需要适应
- 通过 DTO 隔离：你需要修改 DTO 定义、修改领域对象到 DTO 的映射逻辑、修改消费方——改动点更多，而且 DTO 映射层是纯粹的机械代码，不承载任何业务语义

DTO 看似提供了缓冲，但在实践中，当领域结构变化时，DTO 要么跟着变（那隔离是假的），要么不跟着变（那 DTO 就变成了与当前领域模型不一致的遗留结构，增加认知负担）。

**第二，领域对象自身就能管理接口的稳定性，不需要外部间接层。** 如果消费方频繁需要"订单客户所在城市"这个信息，在 Order 上提供一个便捷方法即可：

```java
public String getCustomerCity() {
    return this.customer.getAddress().getCity();
}
```

消费方依赖的是 `order.getCustomerCity()` 这个领域概念，内部导航路径的变化被封装在方法实现中。这不是 DTO，而是领域对象在适当粒度上提供的**领域接口**。

更进一步，当领域模型发生重构时，可以采用类似 GraphQL 的渐进演进策略：保留旧的访问路径作为委托方法并标记为 deprecated，新代码使用新路径，旧消费方按自己的节奏迁移。这种方式不需要任何间接层，变化的管理内建在领域对象自身的演进策略中。

> 需要注意的是，这种便捷方法应该对应有意义的领域概念——比如 getCustomerCity() 如果实际上代表的是"订单的税务归属地"，它就是一个合法的领域接口。但如果它纯粹是某个报表的取数便利，没有独立的领域含义，就不应该放在领域对象上——否则领域对象会逐渐积累消费者导向的方法，反而损害了领域表达的纯粹性。判断标准是：这个方法的命名和语义是否在统一语言中有对应物？如果有，它属于领域对象；如果没有，它应该放在消费方自己的适配层中。

### 导航路径变化反映的是什么

关于"导航路径只是实现细节，同一业务事实可以有不同的编码方式"这个常见反驳：在实践中，领域导航路径的变化几乎总是反映了领域认知的变化，而非纯粹的技术重构。如果 `order.customer.address.city` 变成了 `order.shippingCity`，那是因为我们认识到发货地址和客户地址是两个不同的领域概念——业务事实本身变了，消费方理应更新。而对于那些确实不改变领域事实的内部重构（如提取值对象、重组继承层次），上述的便捷方法和渐进演进策略已经足够应对。

**依赖于技术实现（数据库表结构、HTTP 格式、框架 API）是需要隔离的技术依赖。依赖于领域概念和领域关系（订单有客户、客户有地址）是应该存在的领域依赖。** 混淆二者会导致我们引入大量不必要的间接层，反而增加了系统的复杂度和变更成本。

---

## 五、DDD 没有告诉我们的：系统如何演化

DDD 提供了在某一时刻构建正确模型的方法，但对于一个同样重要的问题——**模型如何随时间演化**——给出的回答是不充分的。

DDD 的现有工具箱中确实包含了应对演化的机制：Event Sourcing 将状态变化记录为事件流，为状态的演化提供了追溯能力；CQRS 使读写模型可以独立演化；上下文映射中的防腐层（ACL）、开放主机服务（OHS）等模式管理了跨上下文的兼容性。**这些工具解决的都是运行时演化和跨上下文兼容性问题。**

但在实际的企业级软件开发中，还存在另一类演化问题——**产品线级别的构建时演化**——DDD 的工具箱中缺少对应物：

- 同一产品部署给不同客户，每个客户要求不同的定制
- 基础产品升级后，客户的定制需要跟着升级，不能丢失
- 某个客户要求删除标准产品中的某个字段或功能
- 多个独立开发的定制需要合并到同一个部署中

在传统 DDD 实践中，应对定制的典型方式是修改源码——为每个客户维护一个代码分支。随着客户数量增加，分支维护成本呈指数增长，最终陷入"合并地狱"。

这个问题的本质是：**DDD 教我们如何构建正确的模型，但没有充分回答同一个领域模型如何在不修改源码的前提下容纳多种业务变体。** 它教我们如何雕塑，但不教我们如何在不破坏原作的前提下修改雕塑。

回顾前文的讨论，我们一直在强调领域模型的结构——对象之间的关联关系、属性的组织方式——构成了一个完整的、可寻址的领域表达体系。在第四节中，我们看到消费方可以通过 `${order.customer.address.city}` 这样的路径直接定位到领域模型中的任何信息。这种寻址能力不仅服务于数据读取，同样可以服务于系统的定制化演化。

如果领域模型的每一个语义单元都拥有一个稳定的、可寻址的位置，那么"定制"就可以被精确地表达为"在某个位置上施加什么变化"——这就是差量（Delta）的概念。在这种思路下，定制不是对源码的修改，而是独立存在的差量描述——描述"相对于标准产品，在哪些位置上有什么不同"。基础产品升级时，差量可以自动应用到新版本上，因为差量引用的是领域结构中的坐标位置，而非源码的物理位置。

这不是 DDD 本身的内容，但它填补了 DDD 在构建时演化维度上的空白，值得 DDD 实践者关注。

---

## 六、常见误区总结

| 误区 | 澄清 |
|---|---|
| DDD 就是实体、值对象、聚合根这些模式 | 这些模式服务于一个更根本的目标：构建技术中立的业务逻辑表达体系 |
| 统一语言就是给代码起个好名字 | 统一语言是知识提炼的过程和产物，发现正确的领域语言比用它写代码困难得多 |
| 聚合根的唯一核心职责是维护一致性 | 聚合根同时也是领域语言最廉价的载体，领域语义表达同样是核心职责 |
| 领域对象之间的导航意味着它们属于同一个聚合 | 聚合的大小由一致性边界决定，导航能力由 Manager/Repository 提供，这是两件不同的事 |
| 跨聚合导航必然带来 N+1 性能问题 | 这是基础设施层的工程问题，batch loading 等机制可以透明解决，领域模型不应为此妥协表达力 |
| 所有业务规则都是聚合根应该维护的"不变式" | 需要严格区分结构性不变式（包括领域概念的本质特征）和可变的业务策略，后者应该外置；但这条边界在不同上下文中可能不同 |
| 跨越聚合边界的所有依赖都是风险 | 依赖于技术实现是风险，依赖于领域概念是正常且必要的；领域对象自身的便捷方法和渐进演进策略足以管理接口稳定性 |
| 限界上下文就是"同一个词有不同含义" | 语言边界只是故事的一半，空间划分带来了设计方法的根本转变——先建墙再摆家具 |
| DDD 是一套完整的设计方法论 | DDD 在运行时演化方面有工具支撑，但在产品线级别的构建时演化方面存在显著空白 |
| 简单系统不需要 DDD | 战略设计（统一语言、边界划分）对任何有一定复杂度的系统都有价值 |

---

## 结语

DDD 的持久价值在于它提出了一个正确的目标：**让代码直接反映业务领域的内在结构，而不是被技术实现的偶然性所扭曲。** 这个目标不会因为技术栈的更迭而过时。

但 DDD 不是终点。它教我们如何构建正确的模型，但没有充分回答模型如何在现实世界的持续变化中保持生命力。对于需要长期演化、深度定制的系统——而这是大多数企业级软件的现实——我们需要在 DDD 的基础上补充对"变化本身"的系统化思考。

好的软件设计不仅要正确地描述当前的业务，还要为未来所有可能的变化预留结构化的空间。前者是 DDD 已经给出的智慧，后者是我们仍在探索的前沿。

本文讨论的多个问题——领域模型作为技术中立的表达体系、领域结构作为信息寻址的基础、差量作为非侵入式演化的载体——指向一个共同的理论基础：领域模型的结构本身构成了一个内禀的坐标系，基于这个坐标系可以系统地实现定位、读取和变更。可逆计算理论对这一洞察进行了数学化的阐述，并提出了 `Y = F(X) ⊕ Δ` 的统一演化公式：通过为领域模型建立内禀的坐标系，使得系统中每一个业务概念都自动获得可被定位和修改的坐标，从而无需事先预测变化点，就能在事后对任意粒度的业务逻辑进行非侵入式的差量定制。具体的理论介绍和工程实践可以参考[可逆计算：下一代软件构造理论](https://zhuanlan.zhihu.com/p/64004026)以及其开源实现 [Nop平台](https://github.com/entropy-cloud/nop-entropy)。