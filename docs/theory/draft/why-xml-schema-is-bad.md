# 为什么XML Schema是一个糟糕的设计？

1. xsd与它定义的xml不是同构关系，导致它非常的不直观，直接违反可逆计算理论中全量是差量的一个特例的断言
2. xsd缺省强制要求子节点有序的，这是不必要的限制
3. xsd以及json schema对于列表结构，都没有引入keyAttr的概念，导致在列表中无法进行唯一定位，也就不可能引入差量计算
4. xsd以及xml都是针对文本结构定义的，无法在运行时存放Number, Boolean以及更加复杂数据类型
5. xsd没有x:post-extends, x:post-parse, x:gen-extends这种元编程能力
6. xsd没有delta定制能力。在delta目录下放同名的文件就会自动覆盖标准路径下的同名文件，并通过x:extends合并两者
7. xdef定义的结构是允许扩展属性和扩展节点存在的，解析的时候会自动解析这些属性。所有带名字空间的属性缺省都不受xdef元模型约束，除非明确指定xdef:check-ns="c"这种强制要求检查

对比beans.xdef和spring 1.0 xsd

差量的定义依赖于坐标系的存在，而坐标系的存在依赖于唯一定位坐标的稳定存在。xsd没有给列表中元素指定keyAttr，就没有唯一稳定坐标

一次定义一个完整概念体确实很有吸引力 但是有时候就会碰到定义了以后又要把其中一部分拆出来用。。？

在xdef中，可以在定义子结构的时候引用已有的定义，但是它仍然表示继续嵌套下去，坐标是向下延展的

面向对象和Lisp本质上都是短程关系，对象-属性，列表-元素，而Tree是长程关联，一次性定义一个完整概念体，同时在这个过程中引入领域坐标的概念

Java pojo=属性 类型 标签 方法
扩展 继承 册除

面向对象在结构层面本质上是Map结构， Map = Map extends Map<Map>，而可逆计算研究的软件结构空间是将底层的Map推广为Tree， Tree = Tree x-extends Tree<Tree>。如果学习过一些抽象数学，就会理解这种推广为什么是本质上不同的

就好像在数学层面矢量结构被推广为张量结构
矢量上的数学被推广为张量上的数学
而现代数学中的很多基本原理本质上需要使用张量语言去表达

> 属性里怎么保存object的,能举个例子吗

Map<String, ValueWithLocation> attributes;  class ValueWIthLocation{  Object value; SourceLocation loc; }  属性中保存的是ValueWithLocation类型，它记录了Location，这对于跟踪差量合并过程，最终明确每个属性的原始来源至关重要。现在基于JSON结构做的大量设计本质上没有理解这一点


xsd+xmlpatch

jsonpatch在可逆计算理论中是一个错误的设计。 A = 0 + A ，全量是差量的特例，差量应该和全量采用同样的形式，这样才能做到差量的差量仍然是一个同样形式的简单差量，这才使得更复杂的元编程成为可能。这些涉及到一系列基本数学原理层面的推理构造，只是凭借经验会在某个推理链条断掉，无法达到可逆计算这种大范围的结构变换

json结构目前其实存在一个问题，列表结构没法补充元数据。 <children x:key-attr="id"> 通过节点形式很容易实现。但是 children: [] 这样就无法处理

全量是差量的一个特例，如果要用同样的json来表达全量和差量，扩展的元数据就必不可少。实际上现代程序语言都引入了无处不在的注解机制，每个语法结构都可以额外引入就在本地的元数据。 在yaml格式中其实存在一些试图给列表补充元数据的扩展设计
