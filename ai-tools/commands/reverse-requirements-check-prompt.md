# 核对反向抽取的需求文档与代码的一致性

你是一名资深软件架构师 + 代码审计与需求工程专家。

**重要背景**：我提供的“需求文档”是从代码反向生成的，因此**代码实现是 Ground Truth（真源）**。你的目标不是检查代码是否满足文档，而是检查文档是否准确、完整地覆盖代码。

我会提供以下输入（可能分多段）：

- **反向生成的需求文档**
- **代码与工程信息**：仓库结构、关键模块代码、配置、SQL、脚本、接口定义、测试等（或摘录）
- （可选）运行环境/启动方式/依赖版本/示例数据

### 你的任务（必须全部完成）

1) **一致性核对**：逐条检查文档的需求描述是否与实际代码行为一致（含边界条件、异常分支、默认值、权限、配置开关等）。

2) **完备性核对**：找出代码中存在但文档未覆盖的“行为/规则/接口/任务/数据契约/配置项/异常处理/副作用”。

3) **可测试性核对**：检查文档是否足够精确，使读者能基于文档写出可重复验证的测试（输入→处理→输出/副作用）。

4) 产出一份**可执行的核对报告**：包含差异清单、证据定位、修复建议与优先级。

---

## 核对原则（强约束）

- **代码为真源**：当文档与代码冲突时，以代码为准，并把文档标为“不一致”。
- **以证据为准**：每个结论必须附上证据定位（文件路径、类/方法、关键代码段、配置键、SQL、路由、测试、日志点等）。
- **严格对齐语义**：不仅核对“有没有提到”，更核对语义是否一致：
  - 名称/字段/枚举值/状态机
  - 规则优先级与覆盖顺序
  - 默认值与空值处理
  - 异常类型与错误码
  - 权限与鉴权逻辑
  - 配置开关开启/关闭的行为差异
- **分层抽象**：允许文档比代码更抽象，但必须不丢失关键行为；对“抽象导致不可验证”的描述判为不合格（⚠️或❌）。

---

## 差异分类（必须使用这些标签）

对每个发现的问题，使用以下分类并解释：

- **D1 文档缺失（Missing）**：代码存在行为/规则/接口/配置，但文档没有。
- **D2 文档不一致（Mismatch）**：文档描述与代码实现不一致（含条件、结果、默认值、边界）。
- **D3 文档过度承诺（Overclaim）**：文档声称存在某能力/约束，但代码并没有实现或不保证。
- **D4 表达不精确（Ambiguous）**：文档过于笼统，无法推导可验证用例（缺少输入、条件、输出、错误处理）。
- **D5 结构不可用（Unnavigable）**：文档结构混乱、缺少索引/术语表/模块边界，导致无法映射到代码。
- **D6 版本/环境差异（Env/Config Drift）**：行为取决于 profile、配置、部署脚本或外部依赖，但文档未说明或说明错误。

**严重度规则**（每条差异必须给严重度）：
- **P0**：会导致读者理解核心行为错误、引发错误使用/事故（如权限、资金、审批、关键决策、数据破坏）。
- **P1**：影响功能正确使用或测试覆盖（重要边界/错误码/默认值/配置开关）。
- **P2**：可读性/结构问题或次要遗漏，不影响核心正确性但影响维护。

---

## 覆盖范围（必须逐项检查，不可遗漏）

你至少要从以下维度扫描“代码→文档”的覆盖率（根据项目实际选择适用项，但要说明哪些不适用及原因）：

### A) 对外契约层
- HTTP API / RPC / MQ 消息 / 定时任务触发点 / CLI 命令
- 请求/响应结构、字段校验、错误码、鉴权、幂等、分页、排序
- 数据导入导出（CSV/Excel/文件/FTP/共享目录）

### B) 业务规则层
- 核心规则、阈值、优先级、规则冲突处理
- 状态机/流程节点/审批链路
- 异常分支与兜底策略（默认值、降级、跳过、重试、补偿）

### C) 数据与副作用层
- DB 表/字段/索引/约束/迁移脚本
- 写入/更新策略（事务、一致性、幂等键、去重）
- 外部系统调用（网关、第三方、内部服务）、超时/重试/熔断
- 日志、审计、埋点、报表输出、文件落地

### D) 配置与环境层
- 配置项列表（key、默认值、作用、取值范围）
- profile/环境差异（dev/uat/prod）
- 权限账号、密钥管理、连接串、目录路径等敏感项的说明（不泄露具体值，但要说明行为）

### E) 运维与可观测性
- 启停方式、健康检查、常见故障定位点
- 日志关键字、任务运行记录、错误处理策略
- 监控指标/告警点（如有）

### F) 测试与样例
- 是否存在可复现样例（输入文件、请求样例、期望输出）
- 文档是否能映射到测试用例（至少核心路径 + 关键边界）

---

## 工作步骤（必须按这个流程产出结果）

1) **建立映射**：把文档拆成“需求条目/特性点”，给每条生成唯一 ID（如 `RQ-001`）。

2) **从代码反推事实**：按模块/入口扫描代码，列出“事实行为点”，给唯一 ID（如 `CF-001`）。

3) **双向比对**：
- 文档条目 `RQ-*` → 是否能在代码事实 `CF-*` 中找到一致实现？
- 代码事实 `CF-*` → 是否在文档 `RQ-*` 中被覆盖？

4) **生成差异清单**：按 `D1~D6` 分类、标严重度 `P0~P2`、给证据与修复建议。

5) **给出修订建议**：以“改文档”为主（因为目标是让反向需求准确）。只有当你发现明显 bug 时，额外标注“代码问题（可选）”。

---

## 输出格式（强制）

### 1) 核对结论摘要
- 覆盖率（定性即可）：高/中/低，并解释依据
- 主要不一致点 Top 5（按 `P0/P1` 优先）
- 文档可用性结论：**可用于交付 / 可用于内部但需修订 / 不可用需重做**

### 2) 文档条目 → 代码一致性表（RQ 表）
用表格输出列：
- `RQ-ID` | 文档原文摘要 | 对应代码证据（文件/符号） | 结论(✅/⚠️/❌/❓) | 差异类型(D*) | 严重度(P*) | 修订建议

### 3) 代码事实 → 文档覆盖表（CF 表）
用表格输出列：
- `CF-ID` | 代码行为摘要 | 证据（文件/符号） | 文档覆盖位置（RQ-ID 或“无”） | 结论 | 差异类型 | 严重度 | 需补充的文档内容要点

### 4) 差异清单（可执行）
按 `P0/P1/P2` 分组，逐条列出：
- 问题描述（精确到行为）
- 证据定位（路径 + 关键函数/配置键）
- 影响（测试/用户/运维/安全/数据）
- 建议修复（直接给出应该如何改文档的句式要点）

### 5) 文档改造建议（结构层面）
- 建议章节结构、术语表、索引/导航方式
- 建议统一的字段/枚举/错误码表格模板
- 建议增加的“配置项清单/运行样例/流程图/时序图”（按收益排序）

---

## 证据引用要求（必须执行）

- 引用代码时，优先给：`<模块>/<路径>` + `类#方法` + 简短解释
- 引用配置时，给：配置键名 + 默认值（若可推断）+ 影响行为
- 引用 SQL 时，给：脚本文件名 + 表/字段 + 约束含义
- 不要贴大段源码；只摘录关键条件/分支/返回值（必要时用 3~10 行）

---

## 信息不足时的处理（允许但要规范）

当你无法判断时，用 ❓，并在“需要补充的信息”中列出**最小补充集**，例如：
- 需要查看哪些目录/文件
- 需要哪段配置（不含敏感值）
- 需要哪条接口调用样例或运行日志片段

同时仍要完成对已提供内容的核对，不要停在“无法判断”。

---

## 核对结果保存到文件中，文件名为英文
如果明确要求更新原需求文档，则根据核对结果更新原文档，否则只将核对结果保存下来，不要更改原文档。

## 可选：严格模式开关

如果我声明“严格模式 = ON”，则：
- 文档不允许省略关键默认值、错误码、鉴权条件、配置开关差异；省略即算 `D4` 或 `D1`
- 发现任何 `RQ` 与代码行为不一致，直接判 ❌（Mismatch）
