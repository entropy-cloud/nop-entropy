<task x:schema="/nop/schema/task/task.xdef" xmlns:x="/nop/schema/xdsl.xdef"
      xmlns:ai="/nop/ai/xlib/ai.xlib" x:dump="true" xmlns:ai-coder="/nop/ai/xlib/ai-coder.xlib"
      defaultUseParentScope="true"  xmlns:file-utils="/nop/task/xlib/file-utils.xlib"
      x:extends="/nop/task/lib/common.task.xml" xmlns:task="task">

    <ai:chatOptions provider="${aiProvider}" model="${aiModel}" contextLength="30000" maxTokens="8000"
                    sessionId="${sessionId}" enableThinking="false"/>

    <task:namespace ai-coder:enabled="true" file-utils:enabled="true"/>

    <input name="inputDir"/>
    <input name="outputDir"/>

    <input name="aiProvider" type="String" mandatory="true"/>
    <input name="aiModel" type="String" mandatory="true"/>
    <input name="sessionId" type="String" optional="true"/>

    <steps>
        <step name="initVars">
            <output name="resolvedInputDir">
                <source>
                    import io.nop.commons.util.FileHelper;
                    const dir = FileHelper.resolveFile(inputDir);
                    return FileHelper.getAbsoluteFile(dir);
                </source>
            </output>
        </step>

        <loop name="visitDir" varName="dir" itemsExpr="fileIt">
            <input name="fileIt">
                <source><![CDATA[
                import io.nop.core.utils.FileIterators;
                return FileIterators.postOrderDepthFirstIterator(resolvedInputDir, false, file=>{
                    if(file.getName().startsWith("."))
                      return false;
                    if(file.getName().equals("docs-en"))
                      return false;
                    return file.isDirectory() and file.list().length > 0;
                });
                ]]></source>
            </input>

            <steps>
                <step name="getDirPath">
                    <output name="dirPath">
                        <source>
                            import io.nop.commons.util.FileHelper;
                            const dirPath = FileHelper.getRelativePath(resolvedInputDir, dir);
                            return dirPath;
                        </source>
                    </output>
                </step>

                <fork name="genDirSummary" varName="filePathList">
                    <producer><![CDATA[
                       import io.nop.core.utils.FileIterators;
                       import io.nop.commons.util.FileHelper;

                       const files = dir.listFiles().map(file=>{
                          if(!file.isFile())
                             return null;

                          if(file.getName().endsWith(".summary.md") || file.getName().endsWith(".dir-summary.md")){
                             return file;
                          }
                          return null;
                       }).filter(file=> file != null);

                       const filePaths = FileIterators.batchTextFilesByCharLimit(files,30*1024).map(fileList=>{
                          return fileList.map(file=> FileHelper.getRelativePath(resolvedInputDir, file));
                       });
                       return filePaths;
                    ]]></producer>

                    <steps>
                        <step name="logFilePaths">
                            <source>
                                logInfo("dirPath={},filePaths={}", dirPath,filePathList);
                            </source>
                        </step>

                        <exit name="checkNotExists">
                            <when><![CDATA[
                               import io.nop.commons.util.FileHelper;
                               const file = FileHelper.resolveFile(outputDir.$appendPath(dirPath + '.dir-summary.md'));
                               return file.exists();
                            ]]></when>
                        </exit>

                        <step name="readFileContents" customType="ai-coder:ReadFileContents">
                            <input name="inputDir"/>
                            <input name="filePaths" value="${filePathList}"/>
                            <output name="RESULT" exportAs="fileContents"/>
                        </step>

                        <step name="genChunkSummary" customType="ai:TaskStep"
                              ai:promptName="summary/dir-chunk-summary" ai:useResponseCache="true">
                            <throttle maxConcurrency="1" maxWait="100000000"/>
                            <input name="content" value="${fileContents.serializeToString()}"/>
                            <output name="RESULT"/>
                        </step>
                    </steps>

                    <aggregator>
                        return aggResults.getSuccessStepResultValues().join("\n\n");
                    </aggregator>

                    <output name="RESULT" exportAs="dirSummary"/>
                </fork>


                <step name="saveSummary" customType="file-utils:WriteText">
                    <input name="outputDir" value="${inputDir}"/>
                    <input name="fileName" value="${dirPath + '.dir-summary.md'}"/>
                    <input name="text" value="${dirSummary}"/>
                </step>
            </steps>
        </loop>
    </steps>
</task>