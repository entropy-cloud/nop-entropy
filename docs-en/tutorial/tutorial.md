# Development Example

Demo video: [A complete example of building a product list page with the Nop platform](https://www.bilibili.com/video/BV1384y1g78L/)

The Nop platform is a concrete implementation of the Reversible Computation theory. To demonstrate the concepts of Reversible Computation, it comes with a low-code development process tailored for admin systems. You can quickly build admin backends in a low-code manner, and out of the box the platform’s built-in mechanisms automatically provide product-level customization capabilities with no special design required. Below we use the `nop-app-mall` project as an example to introduce the Nop platform’s built-in low-code development workflow.

> `nop-app-mall` is a sample e-commerce application. The project is: [nop-app-mall](https://gitee.com/canonical-entropy/nop-app-mall)

> Nop platform open-source repositories:
>
> * gitee: [https://gitee.com/canonical-entropy/nop-entropy](https://gitee.com/canonical-entropy/nop-entropy)
> * github: [https://github.com/entropy-cloud/nop-entropy](https://github.com/entropy-cloud/nop-entropy)

## I. Design the Excel Data Model

First, design a data model in Excel format, defining database tables, fields, and table associations.

![](excel-model.png)

In the Excel model you can specify:

1. Tags: Used for additional annotations on tables, fields, etc. For example, `seq` means the field value is auto-generated by `SequenceGenerator`, and `var` means the field is initialized to a random value and should be marked as a dynamic variable in automated unit tests.

2. Display: Controls whether a field is displayed, whether it can be updated, etc. The auto-generated front-end list and form pages will honor this information.

3. Data Domain: For fields with special business semantics, you can assign a specific data domain. Once the system recognizes the domain, it can handle the field uniformly. For example, `domain=createTime` indicates a creation time field and will be auto-initialized to the current time when a new entity is created.

4. Dictionary: Restrict values to a set of predefined options via data dictionaries. A dictionary can be a Java `enum` class, e.g., `io.nop.xlang.xdef.XDefOverride`. It can also be defined in a yaml file, e.g., `mall/aftersale-status` corresponds to `/nop/dict/mall/aftersale-status.dict.yaml`.

5. Table Associations: Use the [Association List] to configure relationships between tables. [Property Name] is the name of the property in the child entity pointing to the parent entity, and [Association Property Name] is the property in the parent entity pointing to the collection of child entities. For example, in the department table, the association field `parentId` has [Property Name] `parent` and [Association Property Name] `children`. If you do not need to access entity collections via the ORM engine, you don’t need to configure the association property name.

Dictionary tables can be defined directly in the Excel model. During code generation, `dict.yaml` dictionary files are automatically generated from the model.

![](dict-model.png)

For more detailed configuration notes, see [excel-model.md](../dev-guide/model/excel-model.md)

### Reverse Engineering

Demo video: [How to generate an Excel data model via reverse engineering](https://www.bilibili.com/video/BV1Rc411u79d)

Besides manually writing the database model, you can connect to an existing database and use the `nop-cli` command-line tool to reverse analyze the database structure and generate an Excel model.

```shell
java -Dfile.encoding=UTF8 \
    -jar nop-cli.jar \
    reverse-db litemall \
    -c=com.mysql.cj.jdbc.Driver \
    --username=litemall \
    --password=litemall123456 \
    --jdbcUrl="jdbc:mysql://127.0.0.1:3306/litemall?useUnicode=true&characterEncoding=utf-8&useSSL=true&serverTimezone=UTC"
```

The `reverse-db` command of `nop-cli` requires the [database schema name] parameter, e.g., `litemall`, along with `jdbcUrl` and other options to pass JDBC connection information.

After reverse engineering produces the `orm.xlsx` model file, adjust the Maven module name, package name, etc. in the [Configuration] sheet.

![](config-sheet.png)

### Import PowerDesigner or PDManer Models

Use the `nop-cli` tool’s `gen-orm-excel` command to generate an Excel data model from a PowerDesigner PDM physical model.

```shell
java -Dfile.encoding=UTF8 -jar nop-cli.jar gen-orm-excel model/test.pdm
```

PowerDesigner is commercial software. An open-source alternative is the [PDManer metadata modeling tool](https://gitee.com/robergroup/pdmaner).

The `nop-cli` tool can also generate an Excel data model from a PDManer model file:

```shell
java -Dfile.encoding=UTF8 -jar nop-cli.jar gen-orm-excel model/test.pdma.json
```

According to Reversible Computation, PDM models, PDManer models, and Excel models are merely different visual representations of the same ORM domain model. These representations contain the same information and can, in principle, be converted into one another. Leveraging the metaprogramming capabilities of the Nop platform, we can generate ORM model files at compile time from PDM models, allowing PowerDesigner or PDManer to be used directly as visualization tools for ORM models in Nop.

```xml
<!-- app.orm.xml -->
<orm x:schema="/nop/schema/orm/orm.xdef"
     x:extends="base.orm.xml" x:dump="true"
     xmlns:x="/nop/schema/xdsl.xdef" xmlns:xpl="/nop/schema/xpl.xdef">
    <x:gen-extends>
        <pdman:GenOrm src="test.pdma.json" xpl:lib="/nop/orm/xlib/pdman.xlib"
                      versionCol="REVISION"
                      createrCol="CREATED_BY" createTimeCol="CREATED_TIME"
                      updaterCol="UPDATED_BY" updateTimeCol="UPDATED_TIME"
                      tenantCol="TENANT_ID"
        />
    </x:gen-extends>
</orm>
```

`x:gen-extends` is a compile-time execution mechanism. While loading `app.orm.xml`, it dynamically generates an inheritable base model per the Xpl template defined in `x:gen-extends`, and then uses the `x-extends` merge algorithm to apply Delta corrections to the inherited content.

> `x:gen-extends` is built-in syntax in the XLang language. For details, see [xdsl.md](../dev-guide/xlang/xdsl.md)

## II. Generate Initial Project Code

If the Excel data model is ready, use the `gen` command of the `nop-cli` tool to generate the initial project code:

```shell
java -jar nop-cli.jar gen model/app-mall.orm.xlsx -t=/nop/templates/orm
```

The generated content includes:

```
├─app-mall-api       Public API and message definitions
├─app-mall-codegen   Code-gen helper project; updates current code from the ORM model
├─app-mall-dao       Database entity definitions and ORM model
├─app-mall-service   GraphQL service implementations
├─app-mall-web       AMIS page files and View model definitions
├─app-mall-app       Packaging project for testing
├─deploy             DDL scripts generated from the Excel model
```

Nop provides code generation integrated with Maven. Simply add the following to the pom:

```xml
<pom>
    <parent>
        <artifactId>nop-entropy</artifactId>
        <groupId>io.github.entropy-cloud</groupId>
        <version>2.0.0-SNAPSHOT</version>
    </parent>

    <build>
        <plugins>
            <plugin>
                <groupId>org.codehaus.mojo</groupId>
                <artifactId>exec-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
</pom>
```

> If you do not inherit from the `io.github.entropy-cloud:nop-entropy` pom, you will need to add more detailed configuration for the `exec-maven-plugin`.

During Maven packaging, `xgen` code under the project’s `precompile` and `postcompile` directories runs automatically. `precompile` runs before the compile phase, can access all dependencies, but cannot access the current project’s classes. `postcompile` runs after compile and can access compiled classes and resources. For example, the `precompile/gen-orm.xgen` file in the `app-mall-codegen` module contains:

```xml
<c:script>
// 根据ORM模型生成dao/entity/xbiz
codeGenerator.withTargetDir("../").renderModel('../../model/app-mall.orm.xlsx','/nop/templates/orm', '/',$scope);
</c:script>
```

The above is equivalent to running `nop-cli gen` manually. Therefore, once the initial project is generated, you can update the project code from the Excel data model via Maven packaging—no need to use `nop-cli` anymore. The Nop platform uses incremental code generation, so regenerating code does not break manually adjusted business code. For details, see:

[数据驱动的代码生成器](https://zhuanlan.zhihu.com/p/540022264)

For convenience in debugging, the initial code includes two test classes, `AppMallCodeGen.java` and `AppMallWebCodeGen.java`, which you can run directly in IDEA to execute code generation.

The generated code covers the full stack from front-end to back-end. You can compile and run with `mvn install`. With no extra configuration, start the test app with:

```shell
mvn clean install -DskipTests -Dquarkus.package.type=uber-jar

java -Dfile.encoding=UTF8 \
    -Dquarkus.profile=dev \
    -jar app-mall-app/target/app-mall-app-1.0-SNAPSHOT-runner.jar
```

`app-mall-app` starts with an embedded H2 in-memory database and automatically creates tables per the ORM model at startup. Default user is `nop`, password `123`.

## III. Configure Menus and Access Permissions

The generated code includes a permissions definition file: `app-mall-web/src/resources/_vfs/app/mall/auth/_app-mall.action-auth.xml`, which defines default menu entries for each backend entity corresponding to standard CRUD pages.

You can add new menu entries or mark generated entries for deletion in `app-mall.action-auth.xml`.

```xml
 <resource id="goods-manage" displayName="商品管理" icon="ion:grid-outline" resourceType="TOPM"
           routePath="/goods-manage" component="layouts/default/index">
     <children>
         <resource id="mall-goods-list" displayName="商品列表"
                   icon="ant-design:appstore-twotone" component="AMIS"
                   resourceType="SUBM" url="/app/mall/pages/LitemallGoods/main.page.yaml"/>
         <resource id="mall-goods-create" displayName="商品上架"
                   icon="ant-design:appstore-twotone" component="AMIS"
                   resourceType="SUBM" url="/app/mall/pages/LitemallGoods/add.page.yaml"/>
         <resource id="mall-goods-comment" displayName="商品评论"
                   icon="ant-design:appstore-twotone" component="AMIS"
                   resourceType="SUBM" url="/app/mall/pages/LitemallComment/main.page.yaml"/>
     </children>
 </resource>
```

The menu structure follows the `jeecgboot` project’s design. Top-level menus set `resourceType=TOPM` and `component=layouts/default/index`, while specific pages set `resourceType=SUBM`, `component=AMIS`, and `url` to the virtual path of the page file.

## IV. Improve the Backend Services

Based on the Excel data model, Nop automatically generates Meta metadata files and corresponding GraphQL service objects. With simple configuration, you get a fully functional GraphQL backend service. Comparing `LitemallGoodsBizModel.java` in `app-mall` with `AdminGoodsService.java` in the original `litemall` project, it’s clear that Nop avoids a lot of repetitive code; typically you only express the Delta logic that deviates from standard CRUD.

### 4.1 Add Entity Functions

Logic that depends only on the entity’s own fields can be implemented directly as entity methods. For example, `retailPrice` on the product table corresponds to the lowest price among its related products.

```java
class LitemallGoods extends _LitemallGoods{
    /**
     * retailPrice记录当前商品的最低价
     */
    public void syncRetailPrice() {
        LitemallGoodsProduct minProduct = Underscore.min(getProducts(), LitemallGoodsProduct::getPrice);
        BigDecimal retailPrice = minProduct == null ? minProduct.getPrice() : new BigDecimal(Integer.MAX_VALUE);
        setRetailPrice(retailPrice);
    }
}
```

With the NopOrm data access engine, it’s easy to access associated object collections.

> All associated objects and collections are lazily loaded. You can use the `BatchLoadQueue` to prefetch and avoid the common N+1 issue in Hibernate. See [orm.md](../dev-guide/orm/orm.md)

### 4.2 Add CRUD Supplemental Logic

The Nop platform can automatically implement full CRUD logic via the description in XMeta files, for example:

1. Automatically validate parameters based on metadata (non-null, within dictionary ranges, format constraints, etc.)

2. Implement complex filtering, pagination, and sorting

3. Submit master-detail data in one shot and auto-detect changes to detail records

4. When logical delete is enabled, automatically add `deleted=false` to queries

5. Validate unique constraints are not violated (e.g., product names must be unique)

6. Automatically track created-by, created-time, updated-by, updated-time, etc.

7. When deleting an entity, automatically delete all associated objects marked `cascade-delete`

To enhance standard CRUD, override methods like `defaultPrepareSave` in a subclass of `CrudBizModel`. For example, when saving product info, automatically sync the redundant `retailPrice` field on the product.

```java
@BizModel("LitemallGoods")
public class LitemallGoodsBizModel extends CrudBizModel<LitemallGoods> {
    public LitemallGoodsBizModel() {
        setEntityName(LitemallGoods.class.getName());
    }

    @Override
    protected void defaultPrepareSave(EntityData<LitemallGoods> entityData, IServiceContext context) {
        entityData.getEntity().syncRetailPrice();
    }

    @Override
    protected void defaultPrepareQuery(QueryBean query, IServiceContext context) {
        TreeBean filter = query.getFilter();
        if (filter != null) {
            TreeBean keywordsFilter = filter.childWithAttr("name", LitemallGoods.PROP_NAME_keywords);
            if (keywordsFilter != null) {
                Object value = keywordsFilter.getAttr("value");
                TreeBean orCond = or(contains(LitemallGoods.PROP_NAME_name, value), contains(LitemallGoods.PROP_NAME_keywords, value));
                filter.replaceChild(keywordsFilter, orCond);
            }
        }
    }
}
```

The example also overrides `defaultPrepareQuery` to transform complex query conditions from the front end—for instance, a `keywords` filter can be transformed into a fuzzy search on both `keywords` and `name` columns in the database.

### 4.3 Add Database Access

If you add a `mapper` tag for a database table in the Excel model, a `sql-lib.xml` file and a `Mapper` interface will be generated. You can use the `SqlLibManager` mechanism, which is more convenient and powerful than MyBatis, for database access. The `sql-lib` file supports EQL object query syntax as well as native SQL. EQL can adapt to most relational databases via the Dialect model and is generally recommended.

```xml
<!-- LitemallGoods.sql-lib.xml -->
<sql-lib x:schema="/nop/schema/orm/sql-lib.xdef" xmlns:x="/nop/schema/xdsl.xdef">

    <sqls>
        <eql name="syncCartProduct" sqlMethod="execute">
            <arg name="product"/>

            <source>
                update LitemallCart o
                set o.price = ${product.price},
                  o.goodsName = ${product.goods.name},
                  o.picUrl = ${product.url},
                  o.goodsSn = ${product.goods.goodsSn}
                where o.productId = ${product.id}
            </source>
        </eql>
    </sqls>
</sql-lib>
```

Like MyBatis, EL expressions in the `source` section are automatically replaced with SQL parameters. And because EQL can infer field types from the ORM model, you don’t need to specify JDBC parameter types for each expression like in MyBatis. See [sql-lib.md](../dev-guide/orm/sql-lib.md)

Add the corresponding method in the Mapper interface:

```java
@SqlLibMapper("/app/mall/sql/LitemallGoods.sql-lib.xml")
public interface LitemallGoodsMapper {

    void syncCartProduct(@Name("product") LitemallGoodsProduct product);
}
```

The `IEntityDao` in Nop is similar to Spring’s `JpaRepository` but provides more capabilities. See [dao.md](../dev-guide/orm/dao.md)

### 4.4 Add GraphQL Query/Mutation/Loader

Annotate regular Java methods with `@BizQuery/@BizMutation/@BizLoader` to expose them as GraphQL service methods.

```java
@BizModel("NopAuthRole")
public class NopAuthRoleBizModel extends CrudBizModel<NopAuthRole> {
    public NopAuthRoleBizModel() {
        setEntityName(NopAuthRole.class.getName());
    }

    @BizLoader
    @GraphQLReturn(bizObjName = "NopAuthUser")
    public List<NopAuthUser> roleUsers(@ContextSource NopAuthRole role) {
        return role.getUserMappings().stream().map(NopAuthUserRole::getUser)
                .sorted(comparing(NopAuthUser::getUserName)).collect(Collectors.toList());
    }

    @BizMutation
    public void removeRoleUsers(@Name("roleId") String roleId,
                                @Name("userIds") Collection<String> userIds) {
        removeRelations(NopAuthUserRole.class,
                "roleId", "userId",
                roleId, userIds);
    }
}
```

`@BizLoader` adds an extended property to a given object. For example, `NopAuthRole` has no `roleUsers` property, but if you add the property in the `xmeta` file and define a `BizLoader`, then all responses returning `Role` objects can expose this property. For example:

```groovy
query{
    NopAuthRole__get(id: 'admin'){
       name
       roleUsers
    }

    NopAuthRole__findPage(query:$query){
       name
       roleUsers
    }
}
```

For detailed GraphQL docs, see [graphql-java.md](../dev-guide/graphql/graphql-java.md)

### 4.5 Define the xbiz Model

The Nop platform has built-in support for a NoCode development mode. Through the `xbiz` model, you can add or modify `Query/Mutation/DataLoader` in the backend GraphQL model online without changing Java source code.

The `xbiz` model includes a finite state machine. Simple state transitions (e.g., basic approvals) can be configured without Java code.

Using the XDSL built-in `x:gen-extends` mechanism, you can add workflow support to an `xbiz` model with one line:

```xml
<biz>
   <x:gen-extends>
      <!-- 可以动态为业务对象生成工作流相关的后台服务函数-->
      <biz-gen:GenWorkflowSupport/>
   </x:gen-extends>
</biz>
```

> Workflow engine integration is currently in an early stage.

## V. Improve Front-End Pages

### 5.1 Refine Forms and Tables

The View Outline Model (`view.xml`) is a front-end DSL independent of any specific implementation framework and purely business-oriented. It abstracts key elements such as `grid`, `form`, `layout`, `page`, `dialog`, and `action`. With simple configuration, you can describe common CRUD logic. Compared with general-purpose page description models, it is much more compact. For example, to adjust the add/edit pages for products, you write:

```xml
<form id="edit" size="lg">
            <layout>
                ========== intro[商品介绍] ================
                goodsSn[商品编号] name[商品名称]
                counterPrice[市场价格]
                isNew[是否新品首发] isHot[是否人气推荐]
                isOnSale[是否上架]
                picUrl[商品页面商品图片]
                gallery[商品宣传图片列表，采用JSON数组格式]
                unit[商品单位，例如件、盒]
                keywords[商品关键字，采用逗号间隔]
                categoryId[商品所属类目ID] brandId[Brandid]
                brief[商品简介]
                detail[商品详细介绍，是富文本格式]

                =========specs[商品规格]=======
                !specifications

                =========goodsProducts[商品库存]=======
                !products

                =========attrs[商品参数]========
                !attributes

            </layout>
            <cells>
                <cell id="unit">
                    <placeholder>件/个/盒</placeholder>
                </cell>
                <cell id="specifications">
                    <!-- 可以通过gen-control直接指定字段所用控件 -->
                    <gen-control>
                        <input-table addable="@:true" editable="@:true"
                                     removable="@:true" >
                            ...
                        </input-table>
                    </gen-control>
                    <selection>id,specification,value,picUrl</selection>
                </cell>
                <cell id="products">
                    <!-- 可以引用外部view模型中的grid来显示子表 -->
                    <view path="/app/mall/pages/LitemallGoodsProduct/LitemallGoodsProduct.view.xml"
                          grid="ref-edit"/>
                </cell>
            </cells>
</form>
```

`layout` is a specialized layout DSL that separates layout information from the specific field controls. The widget for a field is usually inferred from the data type or data domain (`domain`). You generally only need to supply layout info to render the page. For details, see [layout.md](../dev-guide/xui/layout.md)

Based on the form and grid models, the Nop platform automatically analyzes the backend fields needed by the UI and generates the GraphQL request `selection` part, avoiding discrepancies between UI and backend data caused by manual coding.

### 5.2 Adjust Field Linkage Logic

You can express field linkage logic using data-binding property expressions, e.g.:

```xml
 <cell id="pid">
     <requiredOn>${level == 'L2'}</requiredOn>
     <visibleOn>${level == 'L2'}</visibleOn>
 </cell>
```

### 5.3 Adjust Page Buttons and Navigation Logic

Common page models such as CRUD pages, single-form pages (`simple`), tabbed pages (`tab`), etc., can all be defined and adjusted in the View Outline Model. Page models can directly reference previously defined form and grid models.

> You can customize the `xview.xdef` meta-model file to support more page models.

```xml
        <crud name="main" grid="list">
            <listActions>
                <!--
                修改新增按钮的功能为跳转到新增页面
                -->
                <action id="add-button" x:override="merge-replace" actionType="link" url="/mall-goods-create">

                </action>
            </listActions>

            <!-- bounded-merge表示合并结果在当前模型范围内。基础模型中有，当前模型中没有的子节点，会被自动删除。
                 缺省生成的代码中已经定义了row-update-button和row-delete-button，只是配置了x:abstract=true，
                 因此这里只要声明id，表示启用继承的按钮即可，可以避免编写重复的代码。
             -->
            <rowActions x:override="bounded-merge">
                <!--
                    使用drawer而不是对话框来显示编辑表单
                -->
                <action id="row-update-button" actionType="drawer"/>

                <action id="row-delete-button"/>

            </rowActions>
        </crud>
```

During code generation, CRUD pages and action buttons are generated automatically for each business object and stored in `view` files prefixed with an underscore, e.g., `_LitemallGoods.view.xml`. Therefore, when adjusting button configurations in `LitemallGoods.view.xml`, you only need to express the changes without rewriting the full button definitions.

### 5.4 Visual Designer

The Nop platform currently uses the [Baidu AMIS framework](https://aisuda.bce.baidu.com/amis/zh-CN/docs/index), which describes pages in JSON. You can directly enter the `page.yaml` URL in the browser address bar to view the page (no need to register in front-end routing), for example:

```
http://localhost:8080/index.html?#/amis/app/mall/pages/LitemallGoods/main.page.yaml
```

The actual page is `src/main/resources/_vfs/app/mall/pages/LitemallGoods/main.page.yaml`, whose contents are:

```yaml
x:gen-extends: |
    <web:GenPage view="LitemallGoods.view.xml" page="main"
         xpl:lib="/nop/web/xlib/web.xlib" />
```

This means generating the AMIS description from the `page` model defined in `LitemallGoods.view.xml`.

1. If your page requirements are special and cannot be effectively described by the View Outline Model, you can write the `page.yaml` directly and skip the View Outline Model. In other words, the front-end page retains the full capabilities of AMIS and is not limited by the View Outline Model.

2. Even when hand-writing `page.yaml`, you can still use `x:gen-extends` to import partial `form` or `grid` definitions to simplify your page (nested JSON nodes can also use `x:gen-extends` or `x:extends` for dynamic generation).

3. The View Model defines page presentation logic independent of specific front-end frameworks. In principle, it can be adapted to any front-end technology. The Nop platform plans to support Alibaba’s `LowCodeEngine` in the future.

4. On top of auto-generated JSON pages, you can make Delta corrections to the generated code in `page.yaml` (leveraging XDSL’s built-in Delta merge).

In debug mode, all front-end AMIS pages have two design buttons in the top-right corner.

![amis-editor](amis-editor.png)

1. If you manually modify `page.yaml` or `view.xml` on the backend, click Refresh to update the front end.

2. Click the JSON Design button to open a YAML editor in the browser, allowing you to edit the JSON and see changes immediately.

3. Click the Visual Design button to open the amis-editor visual designer and adjust the page visually. After saving, the designer computes the Delta against the generated View and saves only the Delta to `page.yaml`.

   ![](amis-editor-view.png)

For example, after changing the title of the “Product On-Shelf” page to “Add - Product” in the visual designer and saving, the contents of `add.page.yaml` become:

```yaml
x:gen-extends: |
  <web:GenPage view="LitemallGoods.view.xml" page="add" xpl:lib="/nop/web/xlib/web.xlib" />
title: '@i18n:LitemallGoods.forms.add.$title|新增-商品'
```

The saved content has been converted to a Delta form.

### 5.5 Introduce Custom Modules

The front-end framework source code for the Nop platform is in [nop-chaos](https://gitee.com/canonical-entropy/nop-chaos). Generally, you develop apps using built-in components; in this case, you only need to reference the prebuilt `nop-web-site` module in the Java side—no need to rebuild the front-end `nop-chaos`.

The front-end stack mainly uses Vue 3.0, ant-design-vue, and Baidu AMIS, with some extensions on top of AMIS. For details, see [amis.md](../dev-guide/xui/amis.md). `nop-chaos` has built-in SystemJs module loading and can dynamically load front-end modules. For example:

```json
{
    "xui:import": "demo.lib.js",
    // 同级及下级节点中可以通过demo.xxx来访问demo模块中定义的内容。
}
```

## VI. Development and Debugging

The Nop platform systematically uses metaprogramming and DSLs, and provides a suite of auxiliary tools:

1. All compile-time synthesized models are output to the `_dump` directory with the source location of each node and attribute.

2. The `nop-idea-plugin` module provides an IDEA plugin supporting code completion and format validation per `xdef` meta-model definitions, and breakpoint debugging for the XScript and Xpl languages.

3. Quarkus comes with `graphql-ui`, where you can browse all GraphQL type definitions online with code hints and auto-completion.

For details, see [debug.md](../dev-guide/debug.md)

![](xlang-debugger.png)

![](graphql-ui.png)

## VII. Automated Testing

The Nop platform includes a model-driven automated testing framework that implements fully automated test data setup and verification without special coding.

```java
public class TestLitemallGoodsBizModel extends JunitAutoTestCase {

    @Inject
    IGraphQLEngine graphQLEngine;

    @EnableSnapshot
    @Test
    public void testSave() {
        ContextProvider.getOrCreateContext().setUserId("0");
        ContextProvider.getOrCreateContext().setUserName("test");

        ApiRequest<?> request = input("request.json5", ApiRequest.class);
        IGraphQLExecutionContext context = graphQLEngine.newRpcContext(GraphQLOperationType.mutation,
                "LitemallGoods__save", request);
        Object result = FutureHelper.syncGet(graphQLEngine.executeRpcAsync(context));
        output("response.json5", result);
    }
}
```

`NopAutoTest` uses a record-and-replay mechanism to construct test cases:

1. Extend `JunitAutoTestCase`
2. Write test methods, use `input` to read data and `output` to write results. On first run, inputs and outputs are recorded into the `cases` directory.
3. After success, annotate the test method with `@EnableSnapshot` to enable the recorded snapshots.
4. With snapshots enabled, subsequent runs will initialize an in-memory database from the recorded data and automatically verify both the returned results and the database changes against the recordings.

For more details, see [autotest.md](../dev-guide/autotest.md)

## VIII. Delta Customization

All XDSL model files are stored under `src/resources/_vfs`, forming a virtual file system. This VFS supports Delta layered overlay (similar to Docker’s `overlay-fs`) and has a default layer `/_delta/default` (more layers can be added via configuration). That is, if both `/_vfs/_delta/default/nop/app.orm.xml` and `/nop/app.orm.xml` exist, the version under `_delta` takes effect. In Delta customization files, you can inherit a base model via `x:extends="raw:/nop/app.orm.xml"`, or inherit from the previous layer via `x:extends="super"`.

Compared to conventional customization mechanisms in programming languages, Delta customization is very general and intuitive and independent of concrete implementation details. For example, to extend Hibernate’s built-in `MySQLDialect`, you typically need knowledge of Hibernate and possibly Spring’s integration and configuration of the Dialect in `SessionFactory`. In Nop, you simply add `/_vfs/default/nop/dao/dialect/mysql.dialect.xml`, and all locations using the MySQL Dialect will pick up the new Dialect model.

Delta customizations are stored separately and can be isolated from the main application code. For instance, package customizations as a `nop-platform-delta` module, and consuming systems only need to include that module. You can include multiple delta directories and control layer order via `nop.core.vfs.delta-layer-ids`. For example, `nop.core.vfs.delta-layer-ids=base,hunan` enables two layers: a base product layer and a deployment-specific layer. This lets you achieve productization at very low cost: a largely complete base product can be deployed to different customers without changing the base code—only adding Delta customizations.

In application development, you can use Delta customization to patch platform bugs or enhance platform features. For example, the `app-mall` project customizes `/_delta/default/nop/web/xlib/control.xlib` to add more field control support. If you add an `<edit-string-array>` control, then simply setting a field’s data domain to `string-array` in the Excel model will make the front end use AMIS’s `input-array` to edit the field automatically.

For more details, see [xdsl.md](../dev-guide/xlang/xdsl.md)

## IX. GraalVM Native Compilation

[GraalVM](https://www.graalvm.org/) is Oracle’s next-gen Java VM that supports languages like Python, JavaScript, and R, and can compile Java bytecode into native machine code that runs as an exe, removing the dependency on JDK. Native programs start faster (sometimes tens of times faster), use less CPU and memory, and occupy less disk space.

On top of Quarkus, the Nop platform further simplifies GraalVM support, making it easy to compile apps into native executables.

1. Quarkus itself provides GraalVM adaptations for many third-party libraries.

2. The Nop platform analyzes IoC container configuration, discovers all beans that need dynamic creation, and generates GraalVM configs.

3. All reflection in Nop goes through `ReflectionManager`, which records all reflection usage. When the app runs in debug mode, it generates GraalVM configuration under `src/resources/META-INF/native-image` based on collected reflection info.

Using `app-mall` as an example, compile to a native executable in the following steps: ([GraalVM must be installed first](https://blog.csdn.net/wangpaiblog/article/details/122850438))

```shell
cd app-mall-app
mvn package -Pnative
```

The build output is `target/app-mall-app-1.0-SNAPSHOT-runner.exe`. The exe is currently rather large (146M), mainly because `graalvm.js` takes nearly 60M. If you don’t need dynamic JS packaging, you can remove the `nop-js` dependency.

> You can use `nop-js` only in debug to execute dynamic code. In production, only the generated static JS files are needed.

## Summary

The Nop platform’s built-in Delta-based software production line is illustrated below:

![](delta-pipeline.png)

It can be expressed as:

$$
\begin{aligned} XORM   &= Generator\langle XExcel \rangle + \Delta XORM \\
XMeta &= Generator\langle XORM \rangle + \Delta XMeta \\
GraphQL &= Builder\langle XMeta\rangle + BizModel \\
\\
XView &= Generator\langle XMeta\rangle  + \Delta XView \\
XPage &=  Generator\langle XView\rangle  + \Delta XPage \\
\end{aligned}
$$

Each step in the inference chain is optional: you can start from any step, or completely discard the inferred information from earlier steps. For example, you can manually add an `xview` model without requiring specific `xmeta` support, or directly create a `page.yaml` and write JSON per the AMIS component spec—the capabilities of AMIS are not constrained by the inference pipeline.

In daily development, we often observe similarities and certain inexact derivations across logical structures. For instance, back-end data models are closely tied to front-end pages. In the simplest case, we can infer CRUD pages from the data model, or conversely infer storage structures from form fields. However, such inexact derivations are hard to capture and utilize with existing techniques. If we force some association rules, they apply only to limited scenarios and cause incompatibilities with other technologies, making it hard to reuse existing tools or adapt to evolving requirements.

Grounded in Reversible Computation, the Nop platform provides a standard technical route to realize reuse based on dynamic similarity:

1. By embedded metaprogramming and code generation, you can set up an inference pipeline between any structures A and C.

2. Decompose the pipeline into multiple steps: A => B => C.

3. Further Delta-ize the pipeline: A => `_B` => B => `_C` => C.

4. Each step can temporarily store and pass through extended information not needed at that step.

Concretely, the back-end to front-end inference chain can be decomposed into four major models:

1. XORM: Domain model for the storage layer.

2. XMeta: Domain model for the GraphQL interface layer; can directly generate GraphQL type definitions.

3. XView: Front-end logic understood at the business level, using a small set of UI elements such as forms, tables, and buttons; independent of front-end frameworks.

4. XPage: Page model for a specific front-end framework.
<!-- SOURCE_MD5:fa7110d46bf0e025020f41c200eed7d0-->
