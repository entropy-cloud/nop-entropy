Nop Platform 2.0 is a next-generation low-code development platform built from scratch based on the theory of Reversible Computation. It surpasses traditional component technologies and model-driven architectures at the theoretical level, effectively addressing the problem of coarse-grained software reuse, and overcoming the limitations of low-code platforms—poor extensibility, low performance, and applicability only to a few mature domains.

The Nop platform adopts the Language Oriented Programming paradigm. In application development, instead of directly using general-purpose programming languages (such as Java or C#), one first defines a domain-specific language (DSL) and then uses the DSL to express business logic. The design goal of the Nop platform is to become a simple and easy-to-use Domain Language Workbench. By adding minimal metadata definitions, you automatically obtain corresponding DSL parsers, validators, IDE plugins, debugging tools, etc., and automatically endow DSLs with general language features such as module decomposition, Delta customization, and metaprogramming. In this respect, it is similar to JetBrains’ MPS product, but its design principles and technical implementation path differ fundamentally from MPS.

Traditional component technologies can only reuse the common portions between A and B, which forces the granularity of reuse to be smaller than both A and B, making it theoretically impossible to reuse a complex, complete system. The theory of Reversible Computation explicitly highlights the importance of the inverse element concept in the domain of software construction and, combined with Generative Programming, proposes a systematic technical route to achieve coarse-grained software reuse.

> `App = Delta x-extends Generator<DSL>`

Reversible Computation extends the fundamental principle of reuse from reuse of identical artifacts to reuse of related artifacts, introducing new principles of software construction into the software world that enable a general solution to reuse problems previously impossible with existing techniques. Recent industry innovations based on the Delta concept, such as Docker and kustomize in K8s, can all be given a unified theoretical explanation within the framework of Reversible Computation. For details, see [Reversible Computation: The Next-Generation Theory of Software Construction](https://zhuanlan.zhihu.com/p/64004026).

The Nop platform is a concrete implementation of the theory of Reversible Computation.

1. nop-entropy is the backend component of the Nop platform. It is implemented in Java, does not depend on third-party frameworks, and can be integrated with Quarkus, Spring, or Solon.

2. nop-entropy supports GraalVM and can be compiled into native executables via the Quarkus or Spring Native frameworks. It does not require a JDK at runtime and achieves tens-of-times faster startup.

3. nop-entropy features a cloud-native design with built-in distributed transactions and multi-tenancy. It can run as a standalone instance or as a distributed cluster, provide online API services, and automatically wrap online services targeted at single business objects into batch tasks for batch files. For most business application scenarios, it offers corresponding model support, enabling major functionality with minimal configuration and greatly reducing the need for hand-coding.

4. During development, nop-entropy can serve as a low-code platform that supports incremental development, automatically generating various code and related documentation. At runtime, it can serve as the supporting technology for a no-code platform oriented to end users, allowing customers to adjust business module functionality online and iterate products in a WYSIWYG manner.

5. The Nop platform provides a complete theoretical foundation and underlying toolset for the design and development of DSLs, greatly simplifying the integration of AIGC with business domains. Using the Nop platform’s XDef meta-model and XDSL domain language, AI large models can be rapidly integrated.

6. The Nop platform itself is developed using the Nop platform; about half of its code is automatically generated by tools. Its internal implementation also makes extensive use of the platform’s built-in metaprogramming and Delta merge operation capabilities.

All parts of the Nop platform will be completely open source; no commercial edition will be released. The currently released components mainly include the implementation of the XLang language and foundational frameworks such as ORM, dependency injection container (IoC), distributed configuration (Config), GraphQLEngine, Report Engine, Job Scheduler, Batch Processing Engine, and Rule Engine. Future plans include a Workflow Engine, Business Intelligence (BI), and a Stream Processing Engine, among other commonly used components for business development.

These frameworks are not simple replicas of existing open-source software; they are designed and implemented from scratch according to the requirements of Reversible Computation and incorporate a large number of original designs. With an order-of-magnitude reduction in code volume (less than 150,000 lines of hand-written Java code), the Nop platform delivers more features than comparable open-source frameworks and achieves unprecedented internal consistency, flexibility, and extensibility.

> X = A + B + C
> 
> Y = A + B + D = X + (-C + D) = X + Delta

For a system X that satisfies the principles of Reversible Computation, without decomposing X, we can always supplement it with additional Delta information to transform it into any target Y. Therefore, without modifying the source code of the Nop platform, we can always implement customization of all platform features by supplementing Delta descriptions—for example, customizing database schemas, business logic, visual designers, and more. All business products developed on the Nop platform automatically inherit this Delta customization capability, which can greatly reduce the difficulty of customization for large-scale business software.

## Highlights and Advantages of Nop

The Nop platform provides a new technical architecture for intelligent software manufacturing in the AI era. It is the only open-source platform that solves coarse-grained software reuse at the theoretical level, enabling deep secondary development of large core banking applications for different customers without modifying the base product’s source code.

The Nop platform also offers new ideas for implementing underlying frameworks and engines. Traditionally, each engine (such as the Hibernate ORM engine or the Flowable process engine) is designed and implemented independently, sharing at most a small set of commons packages. The Nop platform treats each engine as a model, explicitly defines the model structure via meta-models, and persists it to text files as a DSL. Leveraging the Nop platform’s underlying infrastructure, DSLs can be quickly developed and extended, allowing all engines to share the platform’s meta-models and metaprogramming capabilities. Each engine then only needs to design its own runtime executor, without rethinking extensibility, flexibility, model visualization, and similar concerns, thereby greatly slimming down engine implementations. In the Nop platform, each engine generally has only a few thousand lines of code—far fewer than open-source frameworks that often run into tens of thousands of lines.

The goal of the Nop platform is not to become a ready-to-use, user-friendly, finely polished development framework, but to explore the next generation of software construction principles and provide future-oriented best practices in software architecture.

## Methodological Origins of Reversible Computation

I have long harbored deep skepticism toward the multitude of design principles and so-called methodologies in the software field. Why do these principles exist, and can their effectiveness be proven scientifically? For instance, we often advocate for high cohesion, low coupling, and separation of concerns—but what exactly qualifies as “high,” what counts as “low,” and to what degree should concerns be separated? In graduate school, I began to develop my own software framework, attempting to introduce ideas from physics and mathematics into software architecture, and around 2007 I proposed a relatively complete theory of Reversible Computation, subsequently validating its effectiveness through extensive product development.

Large software products commonly evolve from order to disorder, corresponding in physics to the second law of thermodynamics—the principle of entropy increase: entropy measures the disorder of a system, and all natural processes inevitably evolve spontaneously toward maximizing disorder; entropy never decreases. If a process is reversible, entropy remains unchanged; if irreversible, entropy increases.

The core of Reversible Computation is reversibility. Reversibility matters not only because it facilitates flexible reuse of software elements; more fundamentally, it reflects the essential operating laws of our world. By adhering to the principles of Reversible Computation, we can effectively control the rate of entropy increase during software evolution. Ideally, if a system were fully reversible, its entropy would remain constant.

In the real world, entropy increase is an inescapable fate. Yet even if we cannot eliminate entropy increase completely, we can choose where it occurs—for example, concentrate entropy increase in the Delta. The requirements of specific customers often contain many random, contingent factors; incorporating them into the system inevitably disrupts the previously unified and balanced structure. If these contingencies can be concentrated in a disposable Delta, the core architecture can be protected from erosion. When the system is delivered to a new customer, we need not carry forward the previous customer’s personalized requirements and can always start from a low-entropy state.

The [theory of Reversible Computation](https://zhuanlan.zhihu.com/p/64004026) seeks to provide a more solid theoretical foundation for software construction. It explicitly proposes elevating “Delta” to a first-class concept and viewing the totality as a special case of Delta (totality = identity element + totality), rebuilding the entire conceptual system of the domain around the concept of Delta. Reversible Computation regards software as an abstract entity in continuous evolution, described by different operational rules at different levels of complexity. It focuses on how the minute Deltas produced during evolution propagate in an orderly fashion within the system and interact with one another.
<!-- SOURCE_MD5:144f7219e1cd9531c55684f2a170e67c-->
