# Where do the advantages of low-code development manifest?

Many people’s understanding of low-code development is limited to visual drag-and-drop. Frankly speaking, if it is merely an auxiliary visual interface, it is hard to claim any fundamental advantage. From a productivity standpoint, programmers with some experience typically write code faster than a visual design interface (many people have a visual designer and still don’t use it), and writing code allows you to leverage abstraction mechanisms such as functions and components for encapsulation, continually reducing the amount of code that must be rewritten. By contrast, using a visual design tool generally binds you to a specific component structure; users are entirely constrained to a fixed level of abstraction, unable to further encapsulate on that basis, and a large number of similar settings end up being repeated across multiple pages. A visual interface can be convenient at the outset for those unfamiliar with component properties or lacking an understanding of general programming concepts; beyond that, its utility is rather limited.

> Some relatively mature low-code platforms offer rich component libraries. Using these carefully designed and tuned components can greatly accelerate development. But essentially, this development advantage does not come from the low-code platform itself; it comes from the component library. If the component library is open-sourced, then writing code directly to reference these libraries can likewise greatly speed up development.

If low-code is regarded merely as a tool-type product, it has both strengths and very obvious weaknesses—for example, debuggability and extensibility are generally far behind traditional development models. However, from the broader perspective of the evolution of programming paradigms, low-code development signifies a new wave of paradigm migration and transformation: declarative programming, riding the tailwind of low-code, is steadily encroaching on the traditional territory of imperative programming, calling for a new, hybrid programming paradigm.
<!-- SOURCE_MD5:d537b429bf5a0490b82a95e65baa96eb-->
