nop.err.ai.coder.headers-and-data-not-match: 表头和数据的列数不匹配:headers={headers},data={data}
nop.err.ai.coder.unknown-sql-type: '未知的SQL类型: {sqlType}'
nop.err.ai.file-content.no-path: 文件对象没有指定路径属性
nop.err.ai.invalid-expr-var-name: 提示词表达式中的变量名无效:{varName}
nop.err.ai.mandatory-input-is-empty: 输入参数{inputName}不能为空
nop.err.ai.mandatory-output-is-empty: 输出参数{outputName}不能为空
nop.err.ai.no-var-in-scope: 上下文中不存在对应变量:{varName}
nop.err.ai.prompt-empty-expr: 提示词表达式内容为空
nop.err.ai.prompt-expr-prefix-unknown: 未定义的提示词表达式前缀:{prefix}
nop.err.ai.prompt-unclosed-expr: 提示词表达式两侧的括号没有正确匹配
nop.err.ai.prompt-var-not-defined: 提示词使用了未定义的变量{varName}
nop.err.ai.service.http-error: 大语言模型{llmName}调用失败，HTTP状态码={httpStatus}
nop.err.ai.service.invalid-response: 大语言模型返回的结果不正确
nop.err.ai.service.no-base-url: 大语言模型{llmName}没有指定baseUrl配置
nop.err.ai.service.no-default-llms: 没有指定调用的大语言模型，也没有配置nop.ai.service.default-llm来指定缺省的大语言模型
nop.err.ai.service.option-not-set: 大语言模型{llmName}没有设置选项{optionName}
nop.err.ai.service.result-invalid-end-line: 大语言模型返回的结果行没有符合预期模式
nop.err.ai.service.result-invalid-number: 大语言模型返回的结果不是数字:name={name},value={name}
nop.err.ai.service.result-is-empty: 大语言模型返回的结果为空
nop.err.ai.service.result-no-expected-part: 大语言模型返回的结果没有符合预期模式, 缺少内容：{expected}
nop.err.ai.unknown-tool-call: 调用的工具未注册:{toolName}
nop.err.antlr.common.parse-fail: 解析失败
nop.err.antlr.lexer-parse-fail: 词法解析失败：{source}
nop.err.antlr.not-end-properly: 语句没有正常结束
nop.err.antlr.string-literal-not-end: 字符串解析失败，没有找到结束符：{source}
nop.err.antlr4.grammar.duplicate-prop-label: 属性名不唯一，不同的部分必须指定不同的altLabel
nop.err.antlr4.grammar.invalid-ast-assign-option: astAssign的格式必须为[属性名]或者[属性名]:[属性值]形式,astAssign={astAssign}
nop.err.antlr4.grammar.invalid-ast-node-name: '未知的AST语法树节点: {astNodeName}'
nop.err.antlr4.grammar.invalid-ast-prop: AST语法树节点[{astNodeName}]的属性[{propName}]未定义
nop.err.antlr4.grammar.invalid-list-element: 列表元素只能是简单的RuleRef定义
nop.err.antlr4.grammar.invalid-list-rule-name: 列表规则[{ruleName}]的规则名应该以_为后缀，所有不以_为后缀的规则都需要返回AST节点
nop.err.antlr4.grammar.list-element-not-ast-node: 列表规则[{ruleName}]只支持解析得到AST节点列表，规则名[{elementRule}]不能以_结尾
nop.err.antlr4.grammar.list-rule-not-allow-prop: 规则[{ruleName}]不支持解析属性[{propName}]，作为列表规则，它只支持通过属性e来标记列表元素
nop.err.antlr4.grammar.not-allow-multiple-alt: 规则内部不允许多个语法分支
nop.err.antlr4.grammar.resource-path-not-file: 资源路径[{path}]必须对应于本地文件路径
nop.err.antlr4.grammar.rule-alternative-is-not-ast-node: '[{ruleName}]的所有子规则都必须解析得到AST节点'
nop.err.antlr4.grammar.rule-with-ast-prop-must-be-ast-node: 指定了astProp属性的解析规则[{ruleName}]必须对应于抽象语法树节点，ruleName不能以_为后缀
nop.err.antlr4.grammar.rule-with-ast-prop-must-be-single-terminal: 指定了astProp属性的解析规则[{ruleName}]必须对应于单一终结符号
nop.err.antlr4.grammar.unknown-rule-ref: 未知的规则名:{ruleName}
nop.err.antlr4.grammar.unsupported-rule: '[{ruleName}]对应于不支持的规则类型'
nop.err.antlr4.invalid-grammar: '[{path}]语法定义文件中存在语法错误'
nop.err.api.annotation-prop-not-allow-empty: 注解[{className}]的属性[{propName}]不允许为空
nop.err.api.beans.invalid-offset-limit-string: offset,limit区间字符串格式不正确:{value}
nop.err.api.beans.source-location-string: SourceLocation字符串格式格式不正确:{value}
nop.err.api.check.invalid-argument: 非法参数
nop.err.api.check.invalid-position-index: 下标[{index}]超出范围，size为{size}
nop.err.api.check.obj-is-frozen: 对象已经被冻结，不允许被修改
nop.err.api.check.value-not-equals: 实际值[{actual}]不等于期待值[{expected}]
nop.err.api.config.value-type-not-allow-change: 获取配置项时指定的数据类型必须与定义时一致，不能发生改变
nop.err.api.config.var-convert-to-type-fail: 配置项({var})类型转换失败：值={value},目标类型={targetType}
nop.err.api.context-already-closed: 上下文对象已经被关闭，不允许再更新：seq={seq}
nop.err.api.context-timeout: 上下文执行时间已超时
nop.err.api.context.provider-already-initialized: ContextProvider已经初始化，不允许再次初始化
nop.err.api.context.provider-not-initialized: ContextProvider尚未初始化或者已经被销毁
nop.err.api.convert-to-type-fail: 数据类型转换错误，无法将值[{value}]转化到类型[{targetType}]
nop.err.api.convert.converter-already-registered: 目标类型[{targetType}]的类型转换器已经存在
nop.err.api.convert.invalid-geo-point-string: 数据点格式不正确:{value}
nop.err.api.convert.invalid-geo-point-wkt-string: 数据点格式不正确:{value},要求格式为POINT(x y)
nop.err.api.exceptions.break: 跳出当前函数
nop.err.api.exceptions.duplicate-singleton-exception-code: 异常码[{errorCode}]已定义
nop.err.api.exceptions.timeout: 超时
nop.err.api.filter-bean-no-op: 判断条件没有设置操作符
nop.err.api.invalid-locale-header: Locale的格式不正确
nop.err.api.ioc.bean-container-not-initialized: Ioc容器尚未初始化
nop.err.api.json.provider-not-initialized: 尚未注册JSON解析器
nop.err.api.json.tree-bean-invalid-attr-name: TreeBean对应的属性名[{attrName}]不是合法的XML名称
nop.err.api.json.tree-bean-invalid-tag-name: TreeBean对应的tag属性[{tagName}]不是合法的XML名称
nop.err.api.message.invalid-integer: 消息头中的的[{header}]字段不是整数类型
nop.err.api.message.invalid-timeout-out-header: 消息头中的的timeout字段格式不合法
nop.err.api.no-service-name-header: 请求头中没有包含nop-svc-name设置
nop.err.api.selection-duplicate-field: 字段选择中字段名重复:{propName}
nop.err.api.template-var-not-allow-null: 模板字符串[{message}]中的变量[{varName}]的值不允许为空
nop.err.api.timeout-expired: 服务调用已超时
nop.err.api.unknown-bean-for-name: 没有名称为[{beanName}]的bean
nop.err.api.unknown-bean-for-type: 没有类型为[{beanType}]的bean
nop.err.api.validate.check-fail: |-
  验证失败:
  {errors}
nop.err.api.wrap: 包装异常
nop.err.auth.no-data-auth: 没有访问类型为[{bizObjName}]的指定实体的权限
nop.err.auth.no-data-auth-after-update: 修改操作不能改变对象的数据权限，导致当前用户无法访问该对象
nop.err.auth.no-permission: 没有访问权限
nop.err.auth.no-permission-for-field: 没有对字段[{fieldName}]的访问权限
nop.err.auth.no-role: 没有访问权限
nop.err.auth.no-user-context: 没有登录用户信息，不允许访问
nop.err.autotest.check-deleted-row-fail: 数据校验失败：数据表[{tableName}]的id为[{id}]的记录没有被删除
nop.err.autotest.check-match-fail: 执行结果不符合预期
nop.err.autotest.check-output-fail: 输出结果[{fileName}]与录制的文件不匹配
nop.err.autotest.check-sql-result-fail: 执行SQL验证失败：{sql}
nop.err.autotest.expect-error: 代码应该抛出异常，不应该执行到这里
nop.err.autotest.no-dao-for-table: 没有找到数据库表[{tableName}]所对应的DAO对象
nop.err.autotest.not-expect-data: 输出[{fileName}]不是期望的结果:expected={expected},output={output}
nop.err.autotest.output-row-not-exists: 数据校验失败：数据表[{tableName}]的id为[{id}]的记录不存在
nop.err.autotest.row-no-id: 文件[{file}]中的数据行[{rowNumber}]没有id
nop.err.autotest.snapshot-finished: 录制快照过程正常结束. 现在可以通过@NopTestConfig的snapshotTest属性来控制录制/校验快照数据
nop.err.autotest.test-class-no-local-db-annotation: 测试方法[{testMethod}]要求使用localDb模式，因此在测试类[{testClass}]上必须增加@NopTestConfig(localDb=true)配置
nop.err.autotest.unknown-file: 文件[{filePath}]不存在
nop.err.batch.cancel-load: 批处理读取被取消
nop.err.batch.cancel-process: 批处理执行被取消
nop.err.batch.input-mandatory-not-provided: 批处理任务的input参数{inputName}是必需的，但未提供
nop.err.batch.invalid-history-store-bean: 批处理任务定义的historyStore的bean配置无效
nop.err.batch.persist-var-convert-type-fail: 状态变量[{varName}]的类型转换失败
nop.err.batch.processor-is-null: 批处理任务的处理器配置不允许为null
nop.err.batch.task-exceed-start-limit: 批处理任务[{taskName}-{taskKey}]启动次数超过限制，不允许再次启动
nop.err.batch.task-invalid-consumer: 批处理的consumer类型不合法
nop.err.batch.task-invalid-loader: 批处理的loader类型不合法
nop.err.batch.task-invalid-processor: 批处理的processor类型不合法
nop.err.batch.task-name-empty: 批处理任务名称为空
nop.err.batch.task-no-loader: 批处理任务没有定义loader
nop.err.batch.task-not-allow-start-when-completed: 批处理任务[{taskName}-{taskKey}]的状态为[{taskStatus}],
  已经完成，不允许再次启动
nop.err.batch.task-not-allow-start-when-exist-running-instance: 批处理任务[{taskName}-{taskKey}]的状态为[{taskStatus}],
  尚未结束，不允许再次启动
nop.err.batch.task-not-allow-start-when-killed: 批处理任务[{taskName}-{taskKey}]的状态为[{taskStatus}],
  已经被终止，不允许再次启动
nop.err.batch.too-many-processing-items: 正在处理的记录过多，程序可能存在内存泄露
nop.err.batch.write-file-fail: 输出到文件失败
nop.err.biz.obj-pk-not-simple: 对象[{objName}]的主键不是简单类型
nop.err.biz.prop-no-biz-obj-name-attr: 对象[{bizObjName}]的属性[{propName}]没有配置bizObjName参数，无法定位它关联的业务对象
nop.err.cli.dir-not-contains-task-file: 目录下不存在后缀名为xrun的任务文件
nop.err.cli.file-not-exists: 文件不存在:{path}
nop.err.cli.file-not-task-file: 任务文件的后缀名必须是xrun
nop.err.cli.model-object-no-xdsl-schema: 模型对象没有设置x:schema属性，不支持转换为XML格式
nop.err.cli.unknown-script: 未找到脚本文件:{path}
nop.err.cli.unregistered-component-model: 模型文件的格式没有在组件管理器中注册，无法解析:{path}
nop.err.codegen.gen-aop-proxy-fail: 生成AOP代理类时失败
nop.err.codegen.import-class-conflicted: 导入的类名[{className1}]和[className2]冲突
nop.err.codegen.invalid-code-visibility: 代码可见性枚举值不正确:{text}
nop.err.codegen.invalid-json-type: j:type属性值应该是list:[{text}]
nop.err.codegen.method-decl-conflicted: 方法定义[{methodName1}]和[methodName2]冲突
nop.err.codegen.path-not-allow-starts-with-or-ends-with-blank: 路径不允许以空白为起始或结尾
nop.err.codegen.static-import-conflicted: 静态导入域[{staticImport1}]和[staticImport2]冲突
nop.err.codegen.unknown-model-type: 模型文件[{fileName}]的类型未注册，可能是没有引入相应的依赖包。比如解析orm.xlsx模型文件需要引入nop-ooxml-xlsx和nop-orm包，而解析api.xlsx需要引入nop-graphql-core包
nop.err.commons.bytes.convert-to-byte-string-fail: 将类型[{srcType}]的值转换到ByteString类型失败
nop.err.commons.cache.duplicate-registration: 注册cache失败，同名的cache已存在:{cacheName}
nop.err.commons.collections.can-not-transform-to-iterator: 不支持转化为Iterator接口
nop.err.commons.collections.iterator-eof: 迭代器已经到达尾部，不能继续移动
nop.err.commons.collections.not-list: 类型为[{class}]的对象不能被转换为集合类型
nop.err.commons.collections.not-support-stream: 不支持转化为Stream接口
nop.err.commons.concurrent.queue-full: 队列已满
nop.err.commons.concurrent.rate-limiter-acquire-count-must-be-less-than-high-watermark: 尝试获取的资源数[{count}]必须比高水位值[{highWatermark}]小
nop.err.commons.concurrent.stop-pooled-thread: 停止线程池中的线程
nop.err.commons.concurrent.unknown-thread-pool: 未知的线程池[{name}]
nop.err.commons.file.acquire-lock-fail: 获取文件锁失败:{path}
nop.err.commons.file.acquire-lock-timeout: 获取文件锁超时:{path}
nop.err.commons.functional.partition-function-is-not-defined-at: 没有找到针对当前参数[{class}]的函数定义
nop.err.commons.functional.undefined-handler-for-request-action: 没有找到针对请求[{action}]的函数定义
nop.err.commons.functional.undefined-handler-for-request-type: 没有找到针对请求类型[{class}]的函数定义
nop.err.commons.io.copy-dest-not-directory: 目录拷贝的目的地已经存在，且不是目录
nop.err.commons.io.copy-dest-not-file: 文件拷贝目标已经存在，且不是文件，无法覆盖
nop.err.commons.io.create-file-fail: 创建文件失败:{path}
nop.err.commons.io.input-size-exceed-limit: 数据流长度超过限制[{limit}]
nop.err.commons.io.not-find-expected-byte: 数据流已结束，没有读取到期待的字节[{expected}]
nop.err.commons.io.peek-count-exceed-limit: 内部缓冲区不支持向前查看[{peekCount}]个字符
nop.err.commons.io.size-exceed-limit: 数据流长度超过最大限制:{maxSize}
nop.err.commons.io.unexpected-eof: 数据流已关闭，无法读取到更多数据
nop.err.commons.io.url-not-resolve-to-file: URL无法被转换为文件对象:{url}
nop.err.commons.lang.null-attribute-value: 属性[{attrName}]的值为空
nop.err.commons.list-not-allow-duplicate-key: 列表元素的唯一键不允许重复
nop.err.commons.list-not-allow-null-element: 列表元素不允许为null
nop.err.commons.load-class-not-expected-type: 加载的类[{className}]不是期望的类型:{expectedType}
nop.err.commons.lock.acquire-fail: 获取锁[{resourceId}]失败
nop.err.commons.lock.invalid-expire-time: 超时时间必须为正数
nop.err.commons.lock.invalid-lease-time: 租期必须为正数
nop.err.commons.lock.invalid-wait-time: 超时时间必须为正数
nop.err.commons.lock.not-allow-reentrant: 锁不允许重入
nop.err.commons.math.not-comparable: v1[{v1}]或者v2[{v2}]非数字类型，它们之间无法比较
nop.err.commons.net.invalid-ip-string: 非法的ip地址:{ip}
nop.err.commons.net.unknown-host: 解析域名[{host}]失败
nop.err.commons.reflect.new-instance-fail: 创建对象实例失败：class={class}
nop.err.commons.service.not-active: 服务[{service}]现在不处于active状态，无法对外提供服务
nop.err.commons.service.not-allow-start-after-stopped: 服务[{service}]停止后不允许再次启动
nop.err.commons.text.buf-limit-exceed-length: 参数limit[{limit}]的值不能超过字符串数组的长度[{length}]
nop.err.commons.text.buf-start-exceed-limit: 参数start的值不能超过limit[{limit}]
nop.err.commons.text.illegal-hex-string: 不是合法的十六进制字符串
nop.err.commons.text.invalid-marker-range: 标记对象的位置超出了文本范围
nop.err.commons.text.invalid-unicode: 非法的unicode字符编码
nop.err.commons.text.invalid-uuid-range: uuid的长度必须是1到64字节之间
nop.err.commons.text.marker-count-mismatch: 标记对象的个数不符合预期
nop.err.commons.text.marker-pos-conflict: 标记对象的位置不能重叠
nop.err.commons.text.number-starts-with-zero: 第一个字符为0的数字表示，例如03
nop.err.commons.text.scan-blank-expected: 当前字符不是空白分隔符
nop.err.commons.text.scan-comment-not-end: 没有找到注释的结束标记[{expected}]
nop.err.commons.text.scan-illegal-escape-char: 非法的转义字符[{cur}], 当前位置:{readerState}
nop.err.commons.text.scan-invalid-char: 非法的字符[{cur}]
nop.err.commons.text.scan-invalid-double-string: 非法的双精度浮点数[{value}]
nop.err.commons.text.scan-invalid-escape-unicode: 非法的Unicode转义字符[{cur}], 当前位置:{readerState}
nop.err.commons.text.scan-invalid-float-string: 非法的单精度浮点数[{value}]
nop.err.commons.text.scan-invalid-hex-int-string: 非法的16进制整数字符串[{value}]
nop.err.commons.text.scan-invalid-long-string: 非法的整数字符串[{value}]
nop.err.commons.text.scan-invalid-number-string: 非法的数字字符串[{value}]
nop.err.commons.text.scan-invalid-prop-path: 非法的属性名称[{value}], 当前位置:{readerState}
nop.err.commons.text.scan-invalid-var: 非法的变量名称[{value}], 当前位置:{readerState}
nop.err.commons.text.scan-invalid-xml-name: 非法的XML名称[{value}]
nop.err.commons.text.scan-next-until-unexpected-eof: 没有找到匹配的字符[{expected}]
nop.err.commons.text.scan-not-allow-two-separator-in-xml-name: Nop的XML名称中不允许连续的.:-分隔符[{value}]
nop.err.commons.text.scan-not-digit: 不是合法的数字字符[{cur}]
nop.err.commons.text.scan-not-end-properly: 遇到非法字符，解析失败
nop.err.commons.text.scan-not-hex-char: 不是合法的十六进制数字字符[{cur}]
nop.err.commons.text.scan-number-not-init: 解析到的数字[{value}]不是整数类型
nop.err.commons.text.scan-read-fail: 读取数据失败
nop.err.commons.text.scan-string-not-end: 字符串没有正常结束
nop.err.commons.text.scan-token-end-expected: 符号之间缺少分隔符。当前位置:{readerState}
nop.err.commons.text.scan-token-incomplete: 符号未正常结束
nop.err.commons.text.scan-unexpected-char: 读取到的下一个字符不是期待的字符[{expected}], 当前位置:{readerState}
nop.err.commons.text.scan-unexpected-str: 读取到的后续字符串不是期待的字符串[{expected}], 当前位置:{readerState}
nop.err.commons.text.scan-unexpected-token: 读取到的后续字符串不是期待的标识符[{expected}], 当前位置:{readerState}
nop.err.commons.text.trie-key-already-exists: Trie树的key不能重复
nop.err.commons.type.invalid-type-index: 非法的类型索引[{index}]
nop.err.commons.type.unknown-type-name: 未知的数据类型:{name}
nop.err.commons.unknown-binary-scalar-type: 未知的二进制标量类型:{typeName}, 允许的类型为:{allowedNames}
nop.err.commons.utils.duplicate-param-name-is-not-allowed-in-simple-query: 简单Query编码不允许重复的参数名:[{paramName}]
nop.err.commons.utils.file-write-conflict: 文件并发写入冲突:{path}
nop.err.commons.utils.invalid-quoted-string: 转义字符串格式不合法:{str}。字符串的起始和结尾字符应该是引用字符
nop.err.commons.utils.invalid-url: URL格式不合法:{url}
nop.err.commons.utils.url-open-stream-fail: URL打开流失败:{url}
nop.err.concurrent.cycle-already-begin: 正在处理过程中，不能再次启动一个处理过程
nop.err.config.invalid-config-bean-name: 不合法的配置对象名:{configName}
nop.err.config.missing-application-name: 缺少nop.application.name配置项
nop.err.config.missing-bootstrap-file: 缺少配置文件:{resourcePath}
nop.err.config.value-not-allow-list: 配置项[{configName}]的值不能是集合类型，只能是普通数据类型或者Map类型
nop.err.config.value-type-not-same-as-defined: 配置值[{configName}]的类型[{valueType}]与定义类型[{defineType}]不一致
nop.err.convert.no-converter-from-type-to-type: 没有从类型 {fromFileType} 转换到类型 {toFileType}
  的转换器
nop.err.convert.no-document-object-builder-for-file-type: 没有为文件类型定义文档对象构建器：{fileType}
nop.err.core.ast-is-read-only: 语法树已经标记为只读，不允许修改
nop.err.core.ast-parent-already-bound: 语法树节点已经绑定到其他父节点。一个节点步允许拥有多个父节点
nop.err.core.bean.set-by-index-not-in-range: setByIndex的参数[{index}]不在有效范围内
nop.err.core.bean.unknown-prop: 类[{className}]上不存在属性[{propName}]
nop.err.core.class-no-default-constructor: 类[className]没有缺省构造函数
nop.err.core.component.cache.duplicate-registration: 注册cache失败，同名的cache已存在:{cacheName}
nop.err.core.component.dep-stack-contains-loop: 组件之间不允许存在循环依赖
nop.err.core.component.invalid-file-type: 模型[{modelType}]的文件类型[{fileType}]格式不合法，只允许fileExt或者xxx.fileExt这两种形式
nop.err.core.component.invalid-model-path: 模型路径格式不合法:{resourcePath}
nop.err.core.component.load-model-not-exist: 模型文件不存在:{resourcePath}
nop.err.core.component.model-file-type-conflict: 类型为[{modelType}]和[{modelType2}]的模型具有同样的文件类型[{fileType}]
nop.err.core.component.model-transformer-already-exists: 从类型[fromModelType]到类型[toModelType]的转换器已经存在
nop.err.core.component.no-component-generator: 类型为[{modelType}]的模型没有指定组件生成器
nop.err.core.component.no-exp-path-strategy: 类型为[{modelType}]的模型没有指定组件路径生成策略
nop.err.core.component.not-allow-change: 模型对象已经被冻结，不允许被修改:{resourcePath}
nop.err.core.component.not-composite-component: 对象不是复合组件类型，不支持通过sub参数来获取子组件
nop.err.core.component.parse-missing-resource: 待解析的资源文件不存在:{resourcePath}
nop.err.core.component.resource-cache-return-null: 装载资源文件返回结果为空:{resourcePath}
nop.err.core.component.undefined-component-model-transform: 组件模型[{modelType}]没有定义转换类型[{transform}]，无法转换到指定类型
nop.err.core.component.unknown-component-file-type: 未知的组件文件类型:{fileType}
nop.err.core.component.unknown-file-type-for-model-type: 模型[{modelType}]不支持文件类型[{fileType}]
nop.err.core.component.unknown-model-file-type: 未知的模型文件类型:{fileType}
nop.err.core.component.unknown-model-type: 未知的模型类型:{modelType}
nop.err.core.context.broken-context-stack: leaveContext和enterContext必须配对调用
nop.err.core.context.svc-ctx-not-bound: 当前线程未绑定IServiceContext
nop.err.core.delta-merge-node-not-inherit: 路径为[{jsonPath}]的节点没有对应可继承的父节点
nop.err.core.dict.build-dict-from-enum-fail: 装载枚举类[{className}]失败
nop.err.core.dict.not-valid-enum-class: '[{className}]不是合法的枚举类'
nop.err.core.dict.unknown-dict: 未知的字典:{dictName}
nop.err.core.dynamic.object-duplicate-prop: 动态对象的属性不允许重名：propName={propName},oldValue={oldValue},newValue={newValue}
nop.err.core.dynamic.object-empty-prop-name: 动态对象的属性名不能为空
nop.err.core.dynamic.object-unknown-method: 动态对象不支持方法:{methodName}
nop.err.core.dynamic.object-unknown-prop: 动态对象不支持属性:{propName}
nop.err.core.eval.disabled-eval-scope: scope已被禁用，不允许访问此方法
nop.err.core.eval.frame.not-supported-operation: 不支持此操作
nop.err.core.eval.function-name-must-starts-with-lower-case: 函数名的首字母必须小写
nop.err.core.eval.output-text-fail: 输出文本失败
nop.err.core.eval.unknown-global-var: '未定义的全局变量: {name}'
nop.err.core.filter.filter-sql-op-invalid-value-type: sql过滤条件的value属性不是SQL数据类型：{value}
nop.err.core.filter.invalid-value-format: 属性[{name}]的值[{value}]格式不正确
nop.err.core.filter.no-name-arg: 类型为[{op}]的判断条件没有指定变量名参数
nop.err.core.filter.op-is-null: 判断条件没有指定类型
nop.err.core.filter.op-not-allow-content: 判断节点只允许包含子节点，不允许文本内容
nop.err.core.filter.unknown-op: 不支持的判断条件类型:{op}
nop.err.core.i18n.duplicated-message-key: i18n消息字符串[{key}]的定义重复:locA={locA},valueA={valueA},locB={locB},valueB={valueB}
nop.err.core.i18n.invalid-message-value: i18n消息字符串[{key}]的值[{value}]不是字符串类型
nop.err.core.json-value-not-node: 值无法转换为XNode类型
nop.err.core.json.bind-expr-invalid-type: 未识别的绑定表达式类型：{type}
nop.err.core.json.bind-options-not-string: 类型[{type}]的绑定表达式的参数必须为字符串
nop.err.core.json.bind-options-not-valid-vpath: 类型[{type}]的绑定表达式的参数必须为虚拟文件路径
nop.err.core.json.doc-not-end-properly: JSON文档没有正常结束
nop.err.core.json.duplicate-key: JSON对象的属性名[{key}]重复
nop.err.core.json.eval-bind-expr-fail: 执行[{key}]对应的JSON数据绑定表达式[{expr}]失败
nop.err.core.json.flatten-key-conflict: 将JSON按key嵌套展平时出现重名的key:[{key}]
nop.err.core.json.json-writer-is-closed: JsonWriter已关闭
nop.err.core.json.list-is-readonly: 只读列表不允许修改
nop.err.core.json.map-is-readonly: 只读容器不允许修改
nop.err.core.json.match-no-pattern: JSON数据中存在多余的字段[{valuePath}]，它的值为[{value}]
nop.err.core.json.match-no-value: 缺少字段[{valuePath}]的值，格式要求为[{pattern}]
nop.err.core.json.only-data-bean-is-serializable: 只有标记为DataBean的数据类型才允许参与JSON序列化
nop.err.core.json.prop-not-string: 属性[{propName}]的值不是字符串类型
nop.err.core.json.serialize-state-fail: JSON序列化状态错误
nop.err.core.json.strict-mode.key-not-double-quoted: 标准JSON语法要求Map的key必须用双引号包裹
nop.err.core.json.strict-mode.string-not-double-quoted: 标准JSON语法要求字符串必须用双引号包裹
nop.err.core.json.string-not-end-properly: 字符串没有正常结束
nop.err.core.json.transform-to-xml-fail: 将JSON对象转换为XNode格式失败
nop.err.core.json.unexpected-char: JSON文件格式不正确
nop.err.core.json.unexpected-exp-extends-result-type: x:exp-extends生成的数据类型必须是List<Map>或者Map，而当前结果类型是[{className}]
nop.err.core.json.unknown-bean-prop: JSON对象上没有定义属性[{propName}]
nop.err.core.json.unknown-deserializer-for-bean: 类[{className}]指定的序列化处理器[{deserializer}]没有注册
nop.err.core.json.unknown-deserializer-for-prop: 类[{className}]的属性[{propName}]指定的反序列化处理器[{deserializer}]没有注册
nop.err.core.json.unknown-serializer-for-bean: 类[{className}]指定的序列化处理器[{serializer}]没有注册
nop.err.core.json.unknown-serializer-for-prop: 类[{className}]的属性[{propName}]指定的序列化处理器[{serializer}]没有注册
nop.err.core.json.value-not-match: 字段[{valuePath}]的值[{value}]不是期待的值[{expected}]
nop.err.core.json.value-not-serializable: JSON序列化失败，遇到不可序列化的值
nop.err.core.json.value-pattern-not-match: 字段[{valuePath}]的值[{value}]不匹配模式[{expected}]
nop.err.core.json.value-size-not-match: 字段[{valuePath}]对应的集合大小[{size}]不是期待的值[{expected}]
nop.err.core.lang.ast-node-invalid-identifier: '[{identifier}]不是合法的变量标识'
nop.err.core.lang.ast-node-not-allow-multiple-parent: AST语法节点不允许存在多个父节点
nop.err.core.lang.ast-node-not-allow-parent: AST语法节点不应该具有父节点
nop.err.core.lang.ast-node-prop-no-enough-items: AST语法节点[{astNode}]的属性[{propName}]最小个数必须大于{minItems}
nop.err.core.lang.ast-node-prop-not-allow-empty: AST语法节点[{astNode}]的属性[{propName}]不允许为空
nop.err.core.lang.ast-node-prop-too-many-items: AST语法节点[{astNode}]的属性[{propName}]最大个数超过限制:{maxItems}
nop.err.core.lang.handler-exceed-max-nested-level: 嵌套层次超过限制:maxLevel={maxLevel}
nop.err.core.lang.handler-state-already-completed: 处理器已进入结束状态，不能再继续处理
nop.err.core.lang.handler-state-incomplete: 处理状态不正确，非正常结束
nop.err.core.loop.same-var-and-src: 循环变量名[{varName}]和来源变量[{srcName}]名不能相同
nop.err.core.loop.src-var-not-defined: 来源变量[{srcName}]尚未被定义
nop.err.core.loop.var-is-already-define: 变量[{varName}]的定义已存在，不能被重复定义
nop.err.core.loop.var-not-defined: 循环变量[{varName}]没有在NestedLoop中定义
nop.err.core.no-api-service-context: 缺少没有Api服务上下文
nop.err.core.no-tenant-id: 上下文环境没有设置租户id
nop.err.core.query.invalid-order-by-sql: 排序语句格式不正确
nop.err.core.reflect.bean-class-no-factory-method: '{className}类没有定义工厂方法，也不是枚举类'
nop.err.core.reflect.bean-no-class-for-type: '{typeValue}没有对应的实现类'
nop.err.core.reflect.bean-no-default-constructor: 类[{className}]没有缺省构造器
nop.err.core.reflect.bean-not-collection-for-getter: 获取集合元素失败，{bean}不是集合类型的对象
nop.err.core.reflect.bean-not-collection-for-setter: 设置集合元素失败，{bean}不是集合类型的对象
nop.err.core.reflect.bean-prop-alias-conflict: 属性[{propName}]的别名[{alias}]与已有别名冲突
nop.err.core.reflect.bean-prop-not-readable: 类[{className}]的属性[{propName}]不可读
nop.err.core.reflect.bean-prop-not-writable: 类[{className}]的属性[{propName}]不可写
nop.err.core.reflect.cast-value-not-target-type: 将类型为[{srcType}]的值转换为目标类型[{targetType}]失败
nop.err.core.reflect.class-model-already-registered: 类[{className}]的反射模型已经存在，不允许重复注册
nop.err.core.reflect.copy-bean-array-length-not-match: 数组拷贝的源数组和目标数组的长度不匹配:src={srcLength},target={targetLength}
nop.err.core.reflect.invalid-ext-prop-name: 扩展属性名[{name}]格式不正确。属性名不允许含有字符.，字符.被保留为复杂属性的分隔符，例如a.b.c
nop.err.core.reflect.invalid-macro-method: '[{className}]类中的方法[{methodName}]标注了@Macro注解，但是函数声明不符合Macro方法要求'
nop.err.core.reflect.invalid-template-string-method: '[{className}]类中的方法[{methodName}]标注了@TemplateStringMethod注解，但是函数声明不符合模板字符串方法要求'
nop.err.core.reflect.invalid-value-text-for-bean: '{text}不是{className}类中定义的合法值'
nop.err.core.reflect.invoke-with-arg-count: 调用函数[{className}.{methodName}]的个数不匹配
nop.err.core.reflect.model-is-readonly: 只读模型不允许修改
nop.err.core.reflect.multiple-factory-method: 不允许多个方法标记为FactoryMethod
nop.err.core.reflect.no-method-for-given-name-and-arg-count: 类[{className}]中名称为[{methodName}]，参数个数为[{count}]的函数不存在或者存在多个无法确定使用哪一个函数
nop.err.core.reflect.not-collection-type: 不是集合类型或者数组类型:{className}
nop.err.core.reflect.not-support-array-class-model: 不支持获取数组类型的ClassModel
nop.err.core.reflect.not-support-get-by-index: '[{className}]不是数组或者列表类型，不支持按照下标获取'
nop.err.core.reflect.not-support-set-by-index: '[{className}]不是数组或者列表类型，不支持按照下标设置值'
nop.err.core.reflect.not-supported-method-for-synthesized-annotation: 注解类[{className}]不支持注解方法[{methodName}]
nop.err.core.reflect.parse-prop-path-fail: 非法的属性路径
nop.err.core.reflect.set-prop-fail: 设置属性失败:{propPath}
nop.err.core.reflect.set-prop-on-null-obj: 设置属性[{propName}]失败，对象为空
nop.err.core.reflect.tree-bean-not-simple-value: TreeBean具有属性或者子节点，不是简单数据类型:{bean}
nop.err.core.reflect.type-invalid-arg: 泛型类型的参数不匹配
nop.err.core.reflect.unknown-bean-class: 未知的bean类型：{className}
nop.err.core.reflect.unknown-bean-prop: 类型为[{className}]的对象不支持属性:{propName}
nop.err.core.reflect.unknown-prop: 对象[{obj}]没有属性[{prop}]
nop.err.core.reflect.unresolved-type: 未定义的类型：{typeName}
nop.err.core.resource.create-new-file-fail: 创建新文件失败：{resource}
nop.err.core.resource.create-temp-file-fail: 在目录{resource}下创建临时文件失败
nop.err.core.resource.current-path-contains-invalid-delta-layer-id: 当前路径[{currentPath}]的deltaLayerId与系统当前配置不符
nop.err.core.resource.dir-not-support-read-write: 目录资源不支持读写操作
nop.err.core.resource.dir-not-support-stream: 目录对象不支持数据流操作:{resource}
nop.err.core.resource.dir-path-should-end-with-slash: 目录对象的路径必须以/结尾:{resourcePath}
nop.err.core.resource.duplicate-vfs-resource: 多个jar包中包含同样的虚拟文件路径[{path}]
nop.err.core.resource.exceed-max-deps-stack-size: 文件可能存在循环依赖：path={resourcePath},root={rootPath}
nop.err.core.resource.get-input-stream-fail: 打开资源文件[{resource}]的输入流失败
nop.err.core.resource.get-output-stream-fail: 打开资源文件[{resource}]的输出流失败
nop.err.core.resource.in-memory-store-not-allow-save: 内存文件存储不支持保存操作
nop.err.core.resource.invalid-delta-id: 路径[{resourcePath}]的deltaLayerId与系统当前配置不符
nop.err.core.resource.invalid-file-path-pattern: 文件路径匹配模式中只允许*和文件名，不支持其他符号
nop.err.core.resource.invalid-module-id: 模块ID必须是A/B这种格式，而现在是：{moduleId}
nop.err.core.resource.invalid-module-name: 模块名必须是A-B这种格式，而现在是:{moduleName}
nop.err.core.resource.invalid-path: 资源路径只能使用/为路径分隔符，且不能以/结尾，不能包含../等相对路径，也不能包含windows路径所不允许的特殊字符:{resourcePath}
nop.err.core.resource.invalid-path-for-classpath-resource: 非法的classpath资源路径
nop.err.core.resource.invalid-relative-name: 相对路径不能以/开始，只能使用/为路径分隔符，不能包含../等相对路径，也不能包含windows路径所不允许的特殊字符:{resourcePath}
nop.err.core.resource.invalid-versioned-path: 资源路径格式不满足要求：{path}
nop.err.core.resource.invalid-zip-entry-name: ZipEntry目录名必须以/结尾:{name}
nop.err.core.resource.is-readonly-file: 只读文件不支持写操作
nop.err.core.resource.module-path-resolve-to-multi-file: 虚拟文件路径[{stdPath}]对应到多个模块文件:{path},{otherPath}
nop.err.core.resource.no-current-path: 上下文环境中没有设置currentPath
nop.err.core.resource.no-length: 文件没有长度属性:{resource}
nop.err.core.resource.not-allow-path: 不允许访问资源路径[{resourcePath}]
nop.err.core.resource.not-contains-file-range: 文件[{resource}]长度为{length}, 无法定位文件区间：[{range}]
nop.err.core.resource.not-dir: 资源对象[{resource}]对应的不是目录
nop.err.core.resource.not-exists: 资源文件[{resourcePath}]不存在
nop.err.core.resource.not-file: 资源对象不是文件对象:{resource}
nop.err.core.resource.now-allow-access-internal-path: 不允许直接访问内部路径:{resourcePath}
nop.err.core.resource.open-input-stream-fail: 打开文件输入流失败：{resource}
nop.err.core.resource.open-output-stream-fail: 打开文件输出流失败：{resource}
nop.err.core.resource.path-not-in-namespace: 资源路径[{resourcePath}]不属于名字空间[{namespace}]
nop.err.core.resource.read-csv-row-fail: 读取CSV文件[{resourcePath}]的第{readCount}行时失败
nop.err.core.resource.read-jsonl-row-fail: 读取JSONL文件[{resourcePath}]的第{readCount}行时失败
nop.err.core.resource.save-from-stream-fail: 保存数据流到资源文件[{resourcePath}]失败
nop.err.core.resource.save-to-resource-fail: 保存资源文件[{src}]到目标[{dest}]失败
nop.err.core.resource.store-not-support-tenant-delta: 文件存储没有开启租户Delta支持
nop.err.core.resource.store.path-not-supported: 不支持的资源存储路径:{resourcePath}
nop.err.core.resource.store.zip-to-dir-fail: 压缩目录[{dir}]到文件[{targetFile}]失败
nop.err.core.resource.stream-skip-to-pos-failed: 跳到文件指定位置[pos]处失败:{resource}
nop.err.core.resource.tpl-not-exists: 模板文件不存在:{tpl}
nop.err.core.resource.unknown-namespace: 资源文件[{resourcePath}]包含未知的名字空间：{namespace}
nop.err.core.resource.unknown-resource-not-allow-operation: 未知资源对象[{resourcePath}]不支持此操作
nop.err.core.resource.versioned-path-no-version: 多版本资源路径的文件名没有包含版本号信息
nop.err.core.resource.virtual-file-system-not-initialized: 虚拟文件系统尚未初始化
nop.err.core.resource.write-to-stream-fail: 保存资源文件[{src}]到数据流中失败
nop.err.core.resource.zip.unzip-to-dir-fail: 解压缩到目录[{dir}]失败
nop.err.core.rpc.prev-call-not-completed: 此前发起的RPC调用尚未完成，无法再发起新的调用
nop.err.core.selection.invalid-arg-name: 参数名[{name}]不合法，它必须满足Java语法规范且不能以$为前缀
nop.err.core.sql.sql-filter-invalid-field-name: SQL字段名不合法:{name}
nop.err.core.sql.sql-param-count-mismatch: SQL参数个数不匹配
nop.err.core.table.invalid-cell-position: 单元格位置表达式不合法:rowIndex={rowIndex},colIndex={colIndex}
nop.err.core.table.invalid-proxy-cell: 位置在({rowIndex},{colIndex})的ProxyCell不合法
nop.err.core.table.invalid-range: 表格区域表达式不合法
nop.err.core.table.invalid-row-range: 行区域表达式不合法
nop.err.core.table.merge-cell-empty-or-proxy-cell: 合并单元格不能是null或者ProxyCell
nop.err.core.table.no-enough-free-space: 表格位置({rowIndex},{colIndex})处没有足够的未占用空间:mergeDown={mergeDown},mergeAcross={mergeAcross}
nop.err.core.table.not-proxy-cell: 位置在({rowIndex},{colIndex})的单元格不是ProxyCell
nop.err.core.table.not-tree-cell: 单元格[{cellPos}]必须在父单元格的范围之内
nop.err.core.table.null-row: 下标为[{rowIndex}]的行为null
nop.err.core.table.row-not-bind-to-table: Row必须加入某个表格，然后才能执行此操作
nop.err.core.tpl.output-bytes-fail: 生成模板输出时失败
nop.err.core.tpl.output-text-fail: 生成文本时失败
nop.err.core.tpl.output-to-resource-fail: 生成到文件时失败
nop.err.core.tree.illegal-visit-state: 遍历树形结构时状态不正确
nop.err.core.tree.table.unsupported-child-pos: 不支持的子节点位置
nop.err.core.type.multiple-raw-type-has-same-name: 同一个类名[{className}]不能对应多个RawType对象
nop.err.core.type.not-allow-function-type-array: '{typeName}是函数类型，不支持函数类型的数组'
nop.err.core.type.not-array-or-list-type: '{typeName}不是数组类型或者列表类型'
nop.err.core.type.not-function-type: '{typeName}不是函数类型'
nop.err.core.type.not-map-type: '{typeName}不是Map类型'
nop.err.core.type.not-predefined-type: '{typeName}不是预定义的泛型类型'
nop.err.core.type.not-structure-type: '{typeName}不是Union/Intersection/Tuple类型'
nop.err.core.type.not-tuple-type: '{typeName}不是Tuple类型'
nop.err.core.type.not-type-variable: '[{typeName}]不是类型变量'
nop.err.core.type.redefine-type-variable: 类型变量[{varName}]已经存在，不允许重复定义
nop.err.core.type.type-reference-not-resolved: 引用了未定义的类型变量:{typeName}
nop.err.core.type.type-string-not-end-properly: 类型定义没有正确结束
nop.err.core.type.unsupported-java-type: 不支持的Java类型
nop.err.core.unittest.exception-with-error-code-expected: 测试用例应该抛出异常，期待的异常消息为[{exception}]
nop.err.core.unittest.invalid-markdown-test-section: 解析测试用例文件失败
nop.err.core.unittest.return-value-mismatch: 测试用例的返回值不符合预期，期待的结果为[{value}]
nop.err.core.unittest.unknown-markdown-section: Markdown测试文件[{fileName}]中没有找到标题为[{title}]的部分
nop.err.core.validate.check-fail: 验证失败
nop.err.core.xml-to-json-output-not-support-mix-text-node: 将XML转换为JSON时不支持混合文本节点
nop.err.core.xml-to-json-output-only-support-simple-text-node: 将XML转换为JSON时只有简单节点允许文本内容
nop.err.core.xml.attach-child-not-allow-null: 追加的XML子节点不允许为null
nop.err.core.xml.attach-child-should-not-has-parent: 追加的XML子节点的父节点必须为null, 一个节点只能有一个父节点
nop.err.core.xml.attr-is-empty: XNode属性[{attrName}]不能为空
nop.err.core.xml.attr-value-not-quoted: XML属性必须以引号包裹
nop.err.core.xml.doc-not-end-properly: XML文档没有正常结束
nop.err.core.xml.duplicate-attr-name: XML节点的属性名重复：attrName={attrName}
nop.err.core.xml.exceed-max-nested-level: XML嵌套层次超过限制
nop.err.core.xml.handler-begin-end-mismatch: beginNode和endNode必须配对调用
nop.err.core.xml.invalid-child-index: 子节点下标[{index}]超出区间
nop.err.core.xml.invalid-instruction: XML指令格式不合法
nop.err.core.xml.invalid-node-json-type: '[{attrName}]的属性值[{attrValue}]不合法，可选值为map,
  list, value'
nop.err.core.xml.invalid-xml-prolog: XML文件头格式不正确
nop.err.core.xml.is-empty: XML文本内容为空
nop.err.core.xml.multiple-child-with-same-tag-name: XML节点[{node}]的多个子节点具有同样的标签名[{tagName}]
nop.err.core.xml.no-xpath-provider: 没有注册XPath解析器
nop.err.core.xml.node-is-readonly: 试图修改只读节点
nop.err.core.xml.not-allow-both-content-and-child: XNode不能同时具有content值和子节点
nop.err.core.xml.not-allow-compile-phase-expr: 不允许使用编译期表达式:{expr}
nop.err.core.xml.not-allow-custom-namespace: '[{xmlName}]不允许自定义的名字空间，允许的名字空间为:{allowedNs}'
nop.err.core.xml.not-allow-empty-prop-name: 访问XNode节点的属性时属性名不能为空
nop.err.core.xml.not-allow-expr: 不允许使用表达式:{expr}
nop.err.core.xml.not-allow-multiple-root: XML文件不允许存在多个根节点
nop.err.core.xml.not-node-value: 值不是XNode类型:{value}
nop.err.core.xml.parse-escape-char-fail: 解析XML转义字符失败
nop.err.core.xml.parse-resource-fail: 解析XML文件失败
nop.err.core.xml.parse-xml-entity-fail: 解析XML entity失败
nop.err.core.xml.string-not-end-properly: 字符串没有正常结束
nop.err.core.xml.tag-end-not-match-tag-start: XML标签没有正常关闭，期待的字符是{expected}
nop.err.core.xml.transform-to-json-fail: 将XNode转换为json格式失败
nop.err.core.xml.unexpected-char: 解析XML失败，下一个字符不是期待的字符
nop.err.core.xml.unexpected-eof: 解析XML结构不完整
nop.err.core.xml.unknown-xml-entity: 未知的XML entity
nop.err.dao.dataset.is-read-only: 只读数据集不允许修改
nop.err.dao.dataset.unknown-column: 未知的数据列:{colName}
nop.err.dao.dialect.data-type-not-supported: 不支持的数据类型:{dataType},允许的数据类型为:{allowedTypes}
nop.err.dao.dialect.invalid-tpl-param: 非法的模板变量:{name},允许的变量为:{allowedNames}
nop.err.dao.dialect.std-data-type-not-supported: 不支持的标准数据类型:{dataType},允许的数据类型为:{allowedTypes}
nop.err.dao.dialect.tpl-param-no-arg: 模板变量的格式必须为name:arg
nop.err.dao.func-invalid-arg-count: 函数[{funcName}]的参数个数必须为{argCount}
nop.err.dao.func-too-few-args: 函数[{funcName}]的参数个数少于最小值{minArgCount}
nop.err.dao.func-too-many-args: 函数[{funcName}]的参数个数超过最大值{maxArgCount}
nop.err.dao.invalid-snowflake-timestamp: 非法的时间戳，系统时钟不允许回拨；ts={ts},lastTs={lastTs}
nop.err.dao.invalid-sql-data-type: 非法的SQL数据类型：{sqlDataType}
nop.err.dao.missing-entity-with-props: 类型为[{entityName}]的记录不存在
nop.err.dao.no-data-source-available: 没有可用的数据库连接池
nop.err.dao.no-dialect-for-datasource: 没有适用于数据库[{productName}]的Dialect
nop.err.dao.query-space-not-jdbc-connection: querySpace[{querySpace}]对应的连接对象不是JDBC连接
nop.err.dao.sql.bad-sql-grammar: SQL语法错误或者数据库对象不存在
nop.err.dao.sql.cannot-serialize-transaction: 数据库事务序列化失败
nop.err.dao.sql.concurrency-failure: 数据库并发冲突导致回滚
nop.err.dao.sql.data-access: 数据库访问失败
nop.err.dao.sql.data-exception: 数据异常
nop.err.dao.sql.data-integrity-violation: 违反数据库完整性约束
nop.err.dao.sql.data-type-conversion-fail: 数据类型转换错误
nop.err.dao.sql.dead-lock: 数据库死锁
nop.err.dao.sql.duplicate-key: 数据库记录的键值冲突
nop.err.dao.sql.feature-not-supported: 不支持的数据库特性
nop.err.dao.sql.invalid-authorization: 数据库权限验证失败
nop.err.dao.sql.invalid-resultset-access: 访问数据集失败
nop.err.dao.sql.recoverable-data-access: 数据访问失败，可获取新的连接再重试
nop.err.dao.sql.timeout: 数据库操作超时
nop.err.dao.sql.transient-connection-fail: 数据库连接暂时失败，可重试
nop.err.dao.sql.uncategorized-failure: 数据库异常
nop.err.dao.txn.already-finished: 事务已经结束，不允许此操作
nop.err.dao.txn.already-started: 事务已经启动，不允许重复启动
nop.err.dao.txn.commit-fail: 事务提交失败
nop.err.dao.txn.duplicate-sub-transaction: 不允许注册多个txnGroup相同的子事务:{txnGroup}
nop.err.dao.txn.not-allow-transaction: 不允许上下文环境中存在已经启动的事务
nop.err.dao.txn.not-in-transaction: 要求上下文环境必须存在已经启动的事务:{querySpace}
nop.err.dao.txn.not-registered: 上下文环境中没有注册的事务对象:{txn}
nop.err.dao.txn.rollback-fail: 事务回滚失败
nop.err.dao.txn.rollback-only-not-allow-commit: 事务标记为只允许回滚，因此不能提交此事务:{txnGroup}
nop.err.dao.unknown-entity: 类型为[{entityName}]，id为[{entityId}]的记录不存在
nop.err.dao.unknown-query-space: 未定义的数据源:{querySpace}
nop.err.eql.cannot-merge-collection-scopes: '无法合并集合操作符作用域: operator1={operator1},
  operator2={operator2}'
nop.err.eql.collection-prefix-mismatch: '集合操作符的collectionPrefix不匹配: scope1=[{collectionPrefix1}],
  scope2=[{collectionPrefix2}]'
nop.err.eql.decorator-arg-count-is-not-expected: 注解[{decorator}]的参数必须为{expectedCount}
nop.err.eql.decorator-arg-type-is-not-expected: 注解[{decorator}]的参数[{argIndex}]的类型不是期待的数据类型:{expected}
nop.err.eql.dialect-not-support-feature: 数据库方言[{dialect}]不支持特性[{feature}]
nop.err.eql.duplicate-table-alias: 数据源[{table1}]和[{table2}]的别名[{alias}]相同
nop.err.eql.field-not-in-subquery: 查询语句的返回结果中没有包含字段:{fieldName}
nop.err.eql.field-not-prop: 字段不是实体上的属性:{fieldName}
nop.err.eql.func-only-allow-in-window-expr: 函数[{funcName}]只允许在窗口表达式中使用
nop.err.eql.func-too-few-args: 函数[{funcName}]的参数个数不足
nop.err.eql.func-too-many-args: 函数[{funcName}]的参数个数过多
nop.err.eql.invalid-datetime-type: 时间日期类型只能是t,s,或者ts
nop.err.eql.invalid-interval-unit: 时间区间类型只能是MICROSECOND/SECOND/MINUTE/HOUR/DAY/WEEK/MONTH/QUARTER/YEAR
nop.err.eql.invalid-sql-type: 未定义的SQL数据类型[{sqlType}]。只允许StdSqlType中定义的常量:{allowedNames}
nop.err.eql.join-no-condition: 表关联没有指定连接条件
nop.err.eql.join-prop-path-is-duplicated: 同一关联属性表达式[{propPath}]不能在join语句中多次定义
nop.err.eql.join-right-source-must-be-prop-path-of-left-source: 关联关系的右侧如果不是实体对象，则必须是左侧对象的关联属性，例如UserInfo
  u left join u.dept
nop.err.eql.multiple-collection-in-same-branch: '同一个逻辑分支不支持多个集合表达式: collection1=[{collection1}],
  collection2=[{collection2}]'
nop.err.eql.not-allow-multiple-query-space: 一条sql语句中的所有表对应的querySpace都必须相同
nop.err.eql.not-single-expr: 不是合法SQL表达式
nop.err.eql.not-support-ilike-operator: 数据库不支持ilike运算符
nop.err.eql.not-support-multi-join-on-alias: 表关联不支持多个别名字段关联条件
nop.err.eql.not-support-multiple-statement: 一次调用只允许执行一条SQL语句
nop.err.eql.only-support-single-table-source: 只支持实体表数据源
nop.err.eql.owner-not-ref-to-entity: 属性表达式的owner必须是实体对象
nop.err.eql.param-not-component: 参数[{paramIndex}]不是IOrmComponent类型[{expected}]
nop.err.eql.param-not-expected-entity: 参数[{paramIndex}]不是期待的实体类型[{expected}]
nop.err.eql.precision-not-positive-int: 数据精度的设置值[{value}]不是正整数
nop.err.eql.prop-path-join-not-allow-condition: 关联属性表达式[{propPath}]时不允许指定关联条件，具体关联条件应根据实体模型的属性定义来自动推定
nop.err.eql.prop-path-not-valid-to-one-reference: 关联属性表达式[{propName}]不是[{entityName}]对象的多对一关联属性
nop.err.eql.query-no-from-clause: sql语句缺乏from子句
nop.err.eql.returning-no-projections: returning语句没有指定选择字段列表
nop.err.eql.scale-not-non-negative-int: 数据小数位数的值[{value}]不是非负整数
nop.err.eql.select-no-projections: select语句没有指定选择字段列表
nop.err.eql.table-source-must-has-alias: 数据源必须具有别名
nop.err.eql.table-source-not-resolved: tableSource没有被成功解析，无法确定它的具体来源
nop.err.eql.unknown-alias: 未知的实体别名[{alias}]
nop.err.eql.unknown-column-name: sql语句使用了未知的列名[{colName}]
nop.err.eql.unknown-entity-name: 未知的实体名[{entityName}]
nop.err.eql.unknown-field-in-entity: 实体[{entityName}]上没有属性:{propName}
nop.err.eql.unknown-field-in-selection: 字段选择列表中没有属性:{propName}
nop.err.eql.unknown-function: 未知的函数[{funcName}]
nop.err.eql.unknown-query-space: sql语句使用了未知的querySpace[{querySpace}]
nop.err.eql.unsupported-eval-expr: 不支持的表达式类型
nop.err.eql.unsupported-op: 不支持的运算符:{op}
nop.err.excel.export.invalid-config-name: 未定义的配置项名称:{name}
nop.err.excel.import-sheet-with-duplicate-key-prop: 导入表格[{sheetName}]时[{keyProp}]的属性重复
nop.err.excel.import.field-value-not-in-dict: 表格[{sheetName}]中的单元格[{cellPos}]的值不在字典表[{dictName}]中
nop.err.excel.import.field-value-validate-fail: '表格[{sheetName}]中的单元格[{cellPos}]的值验证失败:
  {errorDesc}'
nop.err.excel.import.invalid-data-row: 表格[{sheetName}]的第[{rowNumber}]行无法被解析
nop.err.excel.import.list-sheet-model-must-has-field-attr: 表格[{sheetName}]设置了list=true，则它的field属性必须被设置
nop.err.excel.import.mandatory-field-is-empty: 表格[{sheetName}]的必填字段[{fieldName}:{displayName}]的值为空，单元格位置:{cellPos}
nop.err.excel.import.missing-mandatory-field: 表格[{sheetName}]中缺少必填字段[{fieldName}({fieldLabel})]
nop.err.excel.import.missing-mandatory-sheet: 缺少表格[{sheetName}]，名称模式为[{namePattern}]
nop.err.excel.import.multiple-item-with-same-key: 列表属性[{fieldName}]中多个条目的属性[{keyProp}]的值相同：{key}
nop.err.excel.import.unknown-field: 表格[{sheetName}]的单元格[{cellPos}]中指定的字段名[{fieldName}]没有定义，允许的字段名为{allowedNames}
nop.err.excel.import.unknown-group-field: 未知的分组字段:{fieldName}
nop.err.excel.import.unknown-sheet: 未定义的Excel表格:[{sheetName}],允许的名称为{allowedNames}
nop.err.excel.invalid-cell-ref: 非法的单元格引用：{cellRef}
nop.err.excel.invalid-paper-size: 页面大小[{paperSize}]不是允许的值
nop.err.excel.unknown-sheet: Excel文件中没有找到表格:[{sheetName}]
nop.err.excel.validation.boolean-required: 请输入TRUE或FALSE
nop.err.excel.validation.date-required: 请输入有效的日期
nop.err.excel.validation.datetime-required: 请输入有效的日期时间
nop.err.excel.validation.decimal-precision-invalid: 请输入有效的小数，最多[{precision}]位数字，其中小数位最多[{scale}]位
nop.err.excel.validation.decimal-required: 请输入有效的小数
nop.err.excel.validation.field-value-invalid: 字段[{fieldName}]的值不符合要求
nop.err.excel.validation.integer-required: 请输入有效的整数
nop.err.excel.validation.invalid-value: '[{displayName}]的值不符合要求'
nop.err.excel.validation.pattern-mismatch: 输入的值必须符合格式要求：[{pattern}]
nop.err.excel.validation.text-length-invalid: 文本长度不符合要求
nop.err.excel.validation.time-required: 请输入有效的时间
nop.err.excel.validation.title: 数据验证错误
nop.err.exp.undefined-table: 未定义的数据库表:{tableName}
nop.err.exp.unknown-key-field: 数据表[{tableName}]没有定义唯一键字段:{fieldName},已定义的字段名为：{fieldNames}
nop.err.file.already-exists: 文件已经存在:{path}
nop.err.file.copy-fail: '复制文件失败: 从 {sourcePath} 到 {targetPath}'
nop.err.file.delete-fail: '删除文件失败: {path}'
nop.err.file.invalid-path: 路径格式非法
nop.err.file.invalid-regex-pattern: 文件匹配正则表达式格式不正确：{regex}
nop.err.file.move-fail: '移动文件失败: 从 {sourcePath} 到 {targetPath}'
nop.err.file.not-found: '文件不存在: {path}'
nop.err.file.read-fail: '读取文件失败: {path}'
nop.err.file.write-fail: '写入文件失败: {path}'
nop.err.filter.not-allow-expr: Filter不支持的表达式
nop.err.graph.duplicate-vertex: 图节点已经存在
nop.err.graph.nodes-not-reachable: 从起始节点触发无法到达以下节点:{nodeNames}
nop.err.graph.unknown-node: 未知的节点：{name}
nop.err.graphql.action-arg-type-not-obj-type: 动作[{actionName}]的参数[{argName}]的类型不是对象类型:{type}
nop.err.graphql.action-invalid-arg-type: 执行[{actionName}]传入的参数[{argName}]的类型不正确，期待类型为:{expectedType}
nop.err.graphql.action-return-type-must-not-be-api-response: NopGraphQL的服务方法[{methodName}]的返回值类型不需要用ApiResponse包装，直接返回内部结果类型即可
nop.err.graphql.action-with-empty-id-arg: 执行[{actionName}]操作要求id参数不能为空
nop.err.graphql.action-with-empty-ids-arg: 执行[{actionName}]操作要求id参数不能为空
nop.err.graphql.arg-max-must-be-positive: 参数max必须为正整数
nop.err.graphql.batch-load-method-must-return-list: 批量加载方法[{methodName}]必须返回列表数据类型
nop.err.graphql.doc-not-operation: graphql请求不是query/mutation/subscription等操作指令
nop.err.graphql.doc-operation-size-not-one: graphql请求文本中只能包含唯一一个操作语句
nop.err.graphql.duplicate-action: 方法[{method}]和[{oldMethod}]对应的action名称重复，都是[{actionName}]
nop.err.graphql.duplicate-directive-def: 指令定义已存在:{directiveName}
nop.err.graphql.duplicate-field-def: 对象[{objName}]中出现重复定义的字段[{fieldName}]
nop.err.graphql.duplicate-fragment-def: 片段定义已存在:{fragmentName}
nop.err.graphql.duplicate-obj-def: 对象定义已存在:{objName}
nop.err.graphql.duplicate-type-def: 类型定义已存在:{typeName}
nop.err.graphql.duplicated-loader: Loader名称不允许重复:{loaderName}
nop.err.graphql.exceed-max-directive-per-request: 当前请求的Directive个数超出限制，最多允许{maxCount}个
nop.err.graphql.field-complex-type-no-selection: 对象[{objName}]的字段[{fieldName}]不是简单类型，必须指定需要返回的字段集合
nop.err.graphql.field-empty-arg: 函数[{fieldName}]的参数[{argName}]不允许为空
nop.err.graphql.field-extend-type-mismatch: 对象[{objName}]扩展字段[{fieldName}]时指定的类型与原类型不匹配
nop.err.graphql.field-fetcher-already-set: 对象[{objName}]的字段[{fieldName}]已经指定fetcher，不允许再次设置
nop.err.graphql.field-fetcher-is-already-defined: 对象[{objName}]的字段[{fieldName}]存在多个加载器定义
nop.err.graphql.field-name-duplicated: GraphQL的字段名不允许重复:{fieldName},parent={parentName}
nop.err.graphql.field-no-type: 对象[{objName}]中出现的字段[{fieldName}]没有定义数据类型
nop.err.graphql.field-not-allow-selection: 对象[{objName}]中字段[{fieldName}]不是对象类型，不允许选择字段
nop.err.graphql.field-not-scalar: 对象[{objName}]的字段[{fieldName}]不是标量数据类型
nop.err.graphql.field-null-arg: 函数[{fieldName}]的参数[{argName}]不允许为空
nop.err.graphql.field-prop-id-conflict: 对象[{objType}]的字段[{fieldName}]的propId[{propId}]与已存在的propId冲突
nop.err.graphql.introspection-not-enabled: 没有开启GraphQL的introspection支持，不允许访问系统对象
nop.err.graphql.invalid-directive-location: '[{name}]不是合法的directive位置名称，参见GraphQLDirectiveLocation枚举类的定义'
nop.err.graphql.invalid-fragment: 非法的GraphQL片段:{fragmentName}
nop.err.graphql.invalid-fragment-selection-name: GraphQL片段选择器名称不合法:{fragmentName}
nop.err.graphql.invalid-operation-name: 操作名称格式不正确:{operationName}
nop.err.graphql.method-arg-type-not-obj-type: 函数[{methodName}]的参数[{argName}]的类型不是对象类型:{type}
nop.err.graphql.method-param-no-reflection-name-annotation: 方法[{methodName}]上的参数[{argName}]没有@Name注解，也不是引擎可以识别的内部参数
nop.err.graphql.missing-field-arg: 对象[{objName}]的属性[{fieldName}]要求必须传入参数[{argName}]
nop.err.graphql.multi-biz-file-for-biz-obj: 存在多个biz文件对应于同一个对象[{bizObjName}]:pathA={pathA},pathB={pathB}
nop.err.graphql.multi-class-has-same-biz-obj-name: 类[{class}]和[{otherClass}]标记了同样的对象名[{bizObjName}]
nop.err.graphql.multi-meta-file-for-biz-obj: 存在多个meta文件对应于同一个对象[{bizObjName}]:pathA={pathA},pathB={pathB}
nop.err.graphql.not-allow-directive-at-location: GraphQL扩展[{directive}]不允许出现在位置[{location}]
nop.err.graphql.not-obj-type: '[{type}]不是对象类型，不支持字段选择'
nop.err.graphql.not-obj-type-for-field: 对象[{objType}]的属性[{fieldName}]的类型[{type}]未定义
nop.err.graphql.obj-field-type-mismatch-interface: 对象[{objName}]的字段[{fieldName}]类型[{type}]与接口[{interfaceName}]中定义的类型[{expectedType}]不匹配
nop.err.graphql.obj-missing-required-interface-field: 对象[{objName}]实现接口[{interfaceName}]时缺少必需字段[{fieldName}]
nop.err.graphql.only-allow-one-context-source-param: 方法[{methodName}]上最多只允许一个参数具有@ContextSource注解
nop.err.graphql.parse.empty-string: GraphQL查询语句为空
nop.err.graphql.parse.exceed-max-length: GraphQL查询语句过长，超过长度限制
nop.err.graphql.parse.invalid-arg-name: 参数名不合法：{name}
nop.err.graphql.parse.invalid-var-name: 变量名不合法:{name}
nop.err.graphql.parse.unexpected-char: 非法的字符
nop.err.graphql.query.exceed-max-depth: GraphQL查询语句嵌套层次过多，超过最大深度限制。最大深度为{maxDepth}
nop.err.graphql.query.exceed-max-operation-count: GraphQL查询语句包含操作过多，超过最大操作个数限制。最大个数为{maxCount}
nop.err.graphql.query.no-operation: GraphQL查询语句不能为空，必须包含具体的操作
nop.err.graphql.sub-type-of-union-must-be-obj-type: Union类型的子类型必须是对象类型
nop.err.graphql.undefined-field: 对象[{objName}]上没有定义字段[{fieldName}]
nop.err.graphql.undefined-field-arg: 对象[{objName}]的属性[{fieldName}]没有定义参数[{argName}]
nop.err.graphql.undefined-object: 未定义的对象:{objName}
nop.err.graphql.undefined-operation: schema[{operationType}]中没有定义操作:{operationName}
nop.err.graphql.undefined-type: 未定义的类型:{typeName}
nop.err.graphql.unexpected-operation-type: 操作[{operationName}]的类型[{operationType}]不是期望类型[{expectedOperationType}]
nop.err.graphql.unknown-arg-for-directive: directive[{directive}]的参数[{argName}]未定义
nop.err.graphql.unknown-builtin-type: 不支持的系统对象类型：{typeName}
nop.err.graphql.unknown-dict: 没有定义字典:{dictName}
nop.err.graphql.unknown-dict-value-prop: 对象[{objName}]的属性[{propName}]上指定的[{valueProp}]字段未定义
nop.err.graphql.unknown-directive: GraphQL扩展未定义
nop.err.graphql.unknown-fragment: 未定义的GraphQL片段:{fragmentName}
nop.err.graphql.unknown-fragment-selection: 对象元数据中没有定义名称为[{fragmentName}]的片段选择器
nop.err.graphql.unknown-loader: 未定义的Loader:{loaderName}
nop.err.graphql.unknown-obj-type: 未定义的GraphQL类型:{type}
nop.err.graphql.unknown-operation: 未知的请求:{operationName}
nop.err.graphql.unknown-operation-arg: 操作[{operationName}]没有定义参数[{argName}],允许的参数为:{allowedNames}
nop.err.graphql.unknown-try-method: 对象[{bizObjName}]的业务方法[{operationName}]上定义的tryMethod[{cancelMethod}]不存在
nop.err.graphql.unknown-var: 未定义的变量:{varName}
nop.err.graphql.unsupported-ast: 目前不支持的语法节点：{astNode}
nop.err.http.connect-fail: 无法建立http连接
nop.err.http.init-ssl-fail: 初始化SSL失败
nop.err.http.response-error: http响应错误:httpStatus={httpStatus}
nop.err.http.response-format-not-expected: 返回的内容格式不符合预期
nop.err.http.response-text-not-json: 返回的内容不是JSON格式
nop.err.http.timeout: http请求超时
nop.err.imp.duplicate-sheet-alias: 发现重复的表单别名：别名'{alias}'同时被表单'{oldName}'和'{newName}'使用
nop.err.integration.send-sms-fail: 发送短信失败，号码:{mobile},错误码:{errorCode},消息:{msg}
nop.err.ioc..invalid-bean-config-value: bean[{beanName}]的配置值[{value}]格式不正确
nop.err.ioc.alias-conflict: bean的别名[{name}]已经被使用，无法重复定义:locA={locA},locB={locB}
nop.err.ioc.aop-bean-no-bean-class: bean[{beanName}]设置了ioc:aop=true或者ioc:interceptor，则它必须具有class属性
nop.err.ioc.aop-class-no-constructor: bean[{beanName}]对应的AOP代理类没有参数个数为{argCount}的构造函数
nop.err.ioc.bean-aop-proxy-not-generated: bean[{beanName}]指定了interceptor，但没有生成对应的Aop代理类
nop.err.ioc.bean-depend-on-high-order-bean: bean[{beanName}]依赖的bean[{depend}]的优先级比自身的优先级高
nop.err.ioc.bean-depends-graph-contains-loop: bean依赖关系不允许包含循环依赖。如果确实存在，可以在必要的地方配置节点上标注ioc:ignore-depends
nop.err.ioc.bean-scope-already-closed: scope[{beanScope}]已经被关闭
nop.err.ioc.class-no-field: 静态字段[{staticField}]配置不正确，类[className]上不存在字段[{fieldName}]
nop.err.ioc.class-not-annotation: bean[{beanName}]的pointcut配置中用到的类[{className}]不是注解类型
nop.err.ioc.class-not-found: 类[{className}]未找到
nop.err.ioc.container-already-started: 依赖注入容器[{containerId}]已经启动，不允许再次调用start方法
nop.err.ioc.container-not-initialized: IoC容器尚未初始化
nop.err.ioc.container-not-started: bean容器[{containerId}]没有启动，无法访问其中定义的bean
nop.err.ioc.duplicate-bean-definition: bean的名称[{beanName}]与已有的bean的名称或者别名重名，不允许重复定义:locA={locA},locB={locB}
nop.err.ioc.empty-class-name: bean[{beanName}]的class属性必须不为空
nop.err.ioc.empty-config-var: 配置[{configVars}]的值为空
nop.err.ioc.factory-bean-must-be-used-with-factory-method: factory-bean属性必须和factory-method属性一起使用
nop.err.ioc.interceptor-bean-no-pointcut: bean[{interceptorName}]没有配置pointcut，不能作为interceptor使用
nop.err.ioc.invalid-bind-expr: 未定义的表达式[{expr}]类型
nop.err.ioc.invalid-constructor-arg-index: 构造函数的参数顺序不正确
nop.err.ioc.invalid-static-field: 静态字段[{staticField}]的格式不正确
nop.err.ioc.load-aop-class-fail: 加载代理类[{className}]失败
nop.err.ioc.load-class-fail-for-bean: bean[{beanName}]初始化需要使用的类[{className}]装载失败
nop.err.ioc.missing-constructor: id为[{beanName}]的bean缺少参数个数为{paramCount}的构造函数
nop.err.ioc.multiple-bean-with-type: 存在多个bean的类型都是[{beanType}]
nop.err.ioc.multiple-bean-with-type-when-for-prop: bean[{beanName}]的属性[{propName}]需要类型为[{beanType}]的bean，存在多个bean满足要求
nop.err.ioc.multiple-primary-bean: bean[{beanName}]的属性[{propName}]需要类型为[{beanType}]的bean，多个bean都标注了primary，出现冲突
nop.err.ioc.no-config-with-prefix: 没有以[{configPrefix}]为前缀的配置项
nop.err.ioc.not-allow-bean-id-type: bean[{beanName}]为嵌入声明，不允许设置ioc:type=@bean:id
nop.err.ioc.not-allow-both-delay-method-and-bean-method: bean[{beanName}]的定义不允许同时指定bean-method和delay-method属性
nop.err.ioc.not-allow-both-factory-method-and-bean-method: bean[{beanName}]的定义不允许同时指定bean-method和factory-method属性
nop.err.ioc.not-find-bean-with-type: bean[{beanName}]的属性[{propName}]需要类型为[{beanType}]的bean，未找到已注册的bean
nop.err.ioc.not-producer-bean: 不是工厂对象，不支持&语法
nop.err.ioc.parent-ref-contains-loop: bean[{beanName}]的parent属性[{parent}]引用包含循环引用
nop.err.ioc.producer-bean-not-inited: bean[{beanName}]尚未完成初始化，无法访问
nop.err.ioc.proxy-bean-class-not-invocation-handler: 标记了ioc:proxy=true的bean必须实现InvocationHandler接口，而bean[{beanName}]的类型是[{beanClass}],不满足要求
nop.err.ioc.proxy-bean-type-not-interface: bean[{beanName}]标记了ioc:proxy=true，则必须设置ioc:type为接口类型
nop.err.ioc.ref-factory-bean-no-bean-type: 引用的factoryBean[{beanRef}]没有确定的beanType
nop.err.ioc.scope-already-exists: scope[{scope}]已经存在
nop.err.ioc.scope-not-opened: scope[{scope}]没有打开，不能访问其中的bean
nop.err.ioc.unknown-bean-method: 类[{className}]上没有定义方法[{methodName}]
nop.err.ioc.unknown-bean-prop: id为[{beanName}]的bean没有定义属性[{propName}]
nop.err.ioc.unknown-bean-ref: 引用名[{beanRef}]没有指向已定义的bean
nop.err.ioc.unknown-concrete-bean-ref: 引用名[{beanRef}]没有指向已定义的具体的bean
nop.err.ioc.unknown-depend-ref: '[{beanName}]的依赖[{depend}]没有指向已定义的bean'
nop.err.ioc.unknown-ioc-after: bean[{beanName}]的ioc:after指定的依赖[{after}]没有被定义
nop.err.ioc.unknown-ioc-before: bean[{beanName}]的ioc:before指定的依赖[{before}]没有被定义
nop.err.ioc.unknown-parent-ref: bean[{beanName}]的parent属性值[{parent}]没有指向已定义的bean
nop.err.ioc.unresolved-alias: alias[{alias}]对应的bean[{beanName}]未定义
nop.err.javac.not-support-transform-to-xlang-ast-fail: 不支持转换到XLang AST语法树节点
nop.err.javac.parse-fail: 解析java文件失败
nop.err.javaparser.parse-failed: Java解析失败:{parseResult}
nop.err.json.unknown-bind-expr-type: 未知的绑定表达式类型:{type}
nop.err.json.unknown-value-pattern-type: 未知的模式类型:{type}
nop.err.jsonrpc.exceed-max-command-count: JsonRpc单次请求包含的命令过多，超过最大个数限制。最大个数为{maxCount}
nop.err.lang.decode.invalid-message: 消息格式不正确，无法解码
nop.err.layout.invalid-line: 行描述不符合要求
nop.err.layout.unknown-layer-number: 最多只支持#####五层结构
nop.err.log.configurator-not-initialized: LOG提供者没有初始化
nop.err.markdown.invalid-name-value-line: 不是name:value这种格式
nop.err.markdown.missing-section: 'Markdown文本中缺少要求的段落: {title}'
nop.err.markdown.no-section: Markdown文本为空
nop.err.markdown.not-all-child-ordered: 不是所有子节点都是有序节点
nop.err.markdown.not-all-child-section-ordered: 不是所有子项目都是有序节点
nop.err.markdown.section-not-defined-in-tpl: 'Markdown文本中定义的段落在模板中未定义: {title}'
nop.err.match.assert-op-match-fail: 匹配[{jsonPath}]处的值[{value}]不满足匹配条件:filterOp={filterOp}
nop.err.match.between-check-fail: '[{jsonPath}]对应的值[{value}]不在有效的区间范围内：filterOp={filterOp},min={min},max={max}'
nop.err.match.check-match-fail: 匹配[{jsonPath}]处的值[{value}]不满足匹配条件
nop.err.match.compare-op-match-fail: 匹配[{jsonPath}]处的值[{value}]不满足匹配条件:filterOp={filterOp},pattern={pattern}
nop.err.match.config-options-not-map: 配置对象必须是Map类型或者可以被解析为Map的JSON文本
nop.err.match.expr-match-fail: '匹配[{jsonPath}]处的值[{value}]不满足匹配条件: expected={expected}'
nop.err.match.field-not-exists: '[{jsonPath}]对应的字段在数据中不存在'
nop.err.match.field-not-list: '[{jsonPath}]对应的值不是列表类型'
nop.err.match.field-not-object: '[{jsonPath}]对应的值不是对象类型'
nop.err.match.field-value-not-expected: '[{jsonPath}]对应的值与期望值不匹配:value={value},expected={expected}'
nop.err.match.field-value-not-null: '[{jsonPath}]对应的值应该为空，但实际为[{value}]'
nop.err.match.invalid-range-expr: 非法的区间表达式，应该是min,max这种形式
nop.err.match.invalid-var-name: 变量名[{varName}]格式不合法
nop.err.match.list-size-not-match: '[{jsonPath}]对应的列表的大小为{size},不是期待的值：{expected}'
nop.err.match.not-equals-var-value: '[{jsonPath}]对应的值[{value}]与变量[{varName}]的值[{varValue}]不匹配'
nop.err.match.null-pattern-prop: 匹配模式[{patternName}]的属性[{name}]为空
nop.err.match.object-is-null: '[{jsonPath}]对应的值不应为空'
nop.err.match.unknown-pattern: 未定义的模式匹配：{patternName}
nop.err.ooxml.docx.xpl-begin-end-not-match: 通过超链接标注的xpl标签[{tagName}]的起始部分和结束部分[{endTagName}]不匹配:{label}
nop.err.ooxml.docx.xpl-begin-no-end: 通过超链接标注的xpl标签[{tagName}]没有结束部分:{label}
nop.err.ooxml.docx.xpl-end-no-begin: 通过超链接标注的xpl标签[{tagName}]没有起始部分:{label}
nop.err.ooxml.file-path-no-ext: 文件必须具有扩展名:{path}
nop.err.ooxml.invalid-format: 文件格式不正确，解析失败
nop.err.ooxml.lib-namespace-conflict-with-internal-namespace: 标签库[{libPath}]的namespace[{namespace}]与内置的名字空间冲突，以下名字空间已被占用:{nsList}
nop.err.ooxml.link-source-not-xml: 超链接的内容不是XML格式:source={source},label={label}
nop.err.ooxml.unsupported-content-type: 不支持的文件类型:{path}
nop.err.orm.add-null-element-to-collection: 集合元素不允许为null
nop.err.orm.alias-must-ref-to-column-or-reference: 别名[{propName}]必须引用对象模型[{entityName}]中的列或者关联对象
nop.err.orm.bean-not-prototype-scope: Bean的scope必须是prototype:{scope}
nop.err.orm.collection-element-not-allow-multiple-owner: 需要先把[{ownerProp}]属性设置为null，然后才能加入到[{collectionName}]集合中
nop.err.orm.collection-is-readonly: 只读集合不允许被修改:collectionName={collectionName},owner={owner}
nop.err.orm.collection-not-allow-null: 对象[{entityName}]的集合属性[{propName}]不允许为null
nop.err.orm.collection-not-in-session: 集合对象不属于当前session:collectionName={entityName},owner={owner}
nop.err.orm.copy-entity-prop-not-collection: 值的类型是[{propClass}]，不能复制到实体的集合属性[{propName}]上
nop.err.orm.dao.entity-name-not-for-dao: '[{entityName}]不是OrmEntityDao所管理的对象类[{daoEntityName}]'
nop.err.orm.dao.prop-not-to-one-relation: 实体上的[{entityName}]的属性[{propName}]不是对象引用
nop.err.orm.dao.query-example-prop-not-inited: 没有设置查询条件，不允许执行查询
nop.err.orm.dao.update-entity-no-current-session: 更新实体时上下文环境必须存在已经打开的OrmSession
nop.err.orm.dao.update-entity-not-managed: 只有从数据库中成功加载的对象才能调用更新操作。新建的实体只能调用save或者saveOrUpdate，不能调用update。
nop.err.orm.dim-fields-mismatch: '{sourceName}和{subSourceName}的维度字段的个数不匹配'
nop.err.orm.duplicate-short-entity-name: 实体名[{entityName}]和实体名[{otherEntityName}]的短名字重复
nop.err.orm.entity-already-exists: 实体对象[{entityName}:{entityId}]已存在，不允许插入重复的记录
nop.err.orm.entity-id-not-set: 实体的主键字段[{propName}]没有被设置，而且主键字段上没有seq标签，无法自动生成
nop.err.orm.entity-is-readonly: 只读对象不允许被修改:{entity}
nop.err.orm.entity-no-content-prop: 实体模型[{entityName}]没有定义标记为content的字段
nop.err.orm.entity-no-id-prop: 对象[{entityName}]没有定义主键属性，不支持根据id加载
nop.err.orm.entity-not-detached: 执行attache函数之前，实体对象[{entityName}]已经先从原先的session中evict
nop.err.orm.entity-not-in-session: '对象不属于当前session: entityName={entityName},id={entityId}'
nop.err.orm.entity-pk-nop-prop: 实体的复合主键不包含属性[{propName}]
nop.err.orm.entity-prop-id-not-match-def-in-model: 实体[{entityName}]中的属性编号顺序与模型中的定义顺序不一致：编号为[{propId}]的属性在实体中对应属性[{entityPropName}],在模型中对应属性[{propName}]。可能需要重新生成代码。
nop.err.orm.entity-prop-is-dirty: 实体[{entityName}]的属性[{propName}]已经被修改，不允许重新加载
nop.err.orm.entity-prop-not-allow-set: 实体对象[{entityName}:{entityId}]的属性[{propName}]不支持set方法
nop.err.orm.entity-prop-not-ref-collection: 对象[{entityName}]的属性[{propName}]不是集合属性
nop.err.orm.entity-prop-not-ref-entity: 对象[{entityName}]的属性[{propName}]不是对象引用
nop.err.orm.entity-prop-not-updatable: 实体对象[{entityName}]的属性[{propName}]不支持修改
nop.err.orm.entity-prop-type-conversion-fail: 类型转换失败。实体[{entityName}]的属性[{propName}]的类型为[{targetType}],而值[{value}]的类型为[{srcType}]
nop.err.orm.entity-rev-ver-is-less-than-his-ver: 实体对象[{entityName}:{entityId}]的新版本号{revVer}必须大于历史版本号{revBeginVer}
nop.err.orm.entity-set-element-not-kv-table: 集合[{collectionName}]的元素不是IOrmKeyValueTable类型，不支持设置动态属性
nop.err.orm.entity-set-no-key-prop: 集合对象[{collectionName}]没有定义keyProp，不支持作为扩展属性访问
nop.err.orm.entity-unknown-prop: 实体对象[{entityName}:{entityId}]不支持属性[{propName}]
nop.err.orm.entity-version-changed: 实体对象[{entityName}:{entityId}]上的乐观锁版本发生了改变:{oldVersion}=>{version}
nop.err.orm.entity.already-has-entity-model: 实体的元数据对象已经初始化，不允许再次设置
nop.err.orm.entity.no-entity-name: 动态实体的实体类型无法确定
nop.err.orm.entity.null-entity-model: 实体的元数据对象没有初始化
nop.err.orm.entity.prop-change-not-allow-dirty: 已经被修改的字段不允许执行差量更新
nop.err.orm.flush-loop-count-exceed-limit: flush循环的执行次数超过最大限制
nop.err.orm.invalid-composite-pk-part: 对象[{entityName}]的复合主键[{entityId}]的组成部分[{value}]不是期待的数据类型[{targetType}]
nop.err.orm.invalid-composite-pk-part-count: 对象[{entityName}]的复合主键[{entityId}]应该由{count}个部分组成
nop.err.orm.invalid-entity-id: 实体对象[{entityName}]的ID[{entityId}]类型不正确
nop.err.orm.invalid-entity-name: 非法的对象名:{entityName}
nop.err.orm.invalid-field-name: 非法的字段名称:{fieldName}
nop.err.orm.invalid-func-name: 非法的函数名:{funcName}
nop.err.orm.invalid-owner-name: 非法的owner名称:{owner}
nop.err.orm.invalid-prop-id: 实体对象[{entityName}:{entityId}]的propId必须在1和{propIdBound}之间:{propId}
nop.err.orm.lock-entity-fail: 锁定对象[{entityName}:{entityId}]失败
nop.err.orm.lock-entity-must-not-be-dirty: 必须先锁定对象然后才能修改，不允许锁定已经被修改的对象
nop.err.orm.lock-must-run-in-txn: lock语句必须在事务中执行
nop.err.orm.mandatory-prop-is-null: 实体对象[{entityName}:{entityId}]的非空属性[{propName}]为null
nop.err.orm.missing-tenant-id: 实体对象[{entityName}:{entityId}]没有设置租户属性[{propName}]
nop.err.orm.missing-tenant-id-in-context: 访问实体对象[{entityName}:{entityId}]时上下文环境中没有设置租户
nop.err.orm.model.col-data-type-not-match-domain-definition: 实体[{entityName}]上的列[{colName}]的数据类型定义[{dataType}]与数据域上的类型定义[domainDataType]不一致
nop.err.orm.model.col-no-std-sql-type: 实体[{entityName}]上的列[{colName}]上没有设置sql数据类型也没有指定数据域
nop.err.orm.model.compute-prop-no-getter: 实体[{entityName}]的计算属性[{propName}]没有定义getter，不支持获取值
nop.err.orm.model.compute-prop-no-setter: 实体[{entityName}]的计算属性[{propName}]没有定义setter，不支持设置值
nop.err.orm.model.duplicate-col-code: 对象模型[{entityName}]的列[{propName}]和[{otherPropName}]的代码都是[{colCode}]
nop.err.orm.model.duplicate-entity-short-name: 实体[{entityName}]的短名称和实体[{otherEntityName}]的短名称冲突
nop.err.orm.model.duplicate-prop: 对象模型[{entityName}]的属性[{propName}]重复
nop.err.orm.model.duplicate-prop-id: 对象模型[{entityName}]的列[{propName}]和[{otherPropName}]的编号都是[{propId}]
nop.err.orm.model.entity-model-no-pk: 对象模型[{entityName}]没有定义主键
nop.err.orm.model.entity-name-conflicted: 实体名称不能重复:{entityName}
nop.err.orm.model.invalid-column-domain: 实体[{entityName}]上的列[{colName}]上设置的数据域[{domain}]未在模型中定义
nop.err.orm.model.invalid-prop-id: 对象模型[{entityName}]的列[{propName}]的编号必须大于0，小于2000
nop.err.orm.model.invalid-prop-name: 实体[{entityName}]的属性名称[{propName}]格式不正确
nop.err.orm.model.invalid-sql-type: SQL数据类型格式不正确
nop.err.orm.model.join-column-count-less-than-pk-column-count: 实体[{entityName}]的关联引用属性[{propName}]的关联条件个数小于关联实体主键字段的个数，只支持主外键关联
nop.err.orm.model.multiple-label-prop: 实体[{entityName}]上存在多个字段被标记为文本名称字段:{propName},{otherPropName}
nop.err.orm.model.multiple-state-prop: 实体[{entityName}]上存在多个字段被标记为状态字段:{propName},{otherPropName}
nop.err.orm.model.multiple-version-prop: 实体[{entityName}]上存在多个字段被标记为乐观锁字段:{propName},{otherPropName}
nop.err.orm.model.no-col-with-tag: 实体[{entityName}]中没有定义具有标签[{tag}]的列
nop.err.orm.model.ref-depends-contains-loop: 对象模型的依赖关系不能包含循环依赖
nop.err.orm.model.ref-entity-no-prop: 引用对象[{refEntityName}]上未定义属性[{propName}]
nop.err.orm.model.ref-entity-prop-not-primary-key: 关联引用的属性[{propName}]不是引用对象[{refEntityName}]的主键，只支持主外键关联
nop.err.orm.model.ref-join-must-be-on-columns-or-id: 关联属性[{refName}]的关联条件必须定义在数据列或者主键属性上
nop.err.orm.model.ref-join-no-condition: 对象[{entityName}]上的关联属性[{refName}]的关联条件为空
nop.err.orm.model.ref-prop-not-column: 实体[{entityName}]的关联属性[{propName}]不是数据库中的列，只支持主外键关联
nop.err.orm.model.ref-unknown-entity: 对象模型[{entityName}]的属性[{refName}]引用了未知的对象[{refEntityName}]
nop.err.orm.model.relation-join-is-empty: 对象[{entityName}]的属性[{refName}]所对应的关联条件为空
nop.err.orm.model.unknown-collection-name: 未定义的对象集合:{collectionName}
nop.err.orm.model.unknown-column: 实体[{entityName}]上没有定义列[{colName}]，注意这里是Java属性名而不是数据库字段名
nop.err.orm.model.unknown-column-code: 实体[{entityName}]上没有代码为[{colCode}]的列
nop.err.orm.model.unknown-column-prop-id: 实体[{entityName}]上没有定义编号为[{propId}]的列
nop.err.orm.model.unknown-component-prop: 组件对象[{componentClass}]上没有定义属性[{propName}]
nop.err.orm.model.unknown-entity-model-for-table: 没有定义实体模型对应于数据库表:{tableName}
nop.err.orm.model.unknown-entity-name: 未定义的对象名:{entityName}
nop.err.orm.model.unknown-prop: 实体[{entityName}]上没有定义属性[{propName}]
nop.err.orm.model.unknown-prop-id: 实体[{entityName}]上没有定义编号为[{propId}]的列
nop.err.orm.no-permission-for-sql: 没有访问权限
nop.err.orm.nop-update-time-col: 实体[{entityName}]没有定义修改时间字段
nop.err.orm.not-allow-process-entity-in-other-tenant: 不允许访问其他租户中的数据
nop.err.orm.not-current-revision: 实体对象[{entityName}:{entityId}]的版本[{revEndVer}]不是最新版本
nop.err.orm.not-in-session: 上下文环境中没有打开的ORM会话
nop.err.orm.not-singleton-set: 集合[{collectionName}]中的元素个数不是1，不是单例集合
nop.err.orm.not-support-compute: 对象[{entityName}:{entityId}]不支持计算属性[{propName}]
nop.err.orm.not-support-multiple-query-space-in-one-sql: 一条SQL语句只允许访问一个数据源:sql={sql},querySpace={querySpace}
nop.err.orm.null-binder-for-column: 对象[{entityName}]的列[{colName}]的类型为[{sqlType}],没有找到对应的数据绑定接口
nop.err.orm.prop-id-is-reserved: 对象模型[{entityName}]的属性名不能为id，id为系统保留名称
nop.err.orm.query-invalid-join: 不支持的join类型
nop.err.orm.query-no-dim-fields: 查询对象没有指定dimFields属性
nop.err.orm.query-not-allow-group-by: 查询列表中包含关联子表字段时不支持group by
nop.err.orm.query-timeout: 执行查询超时
nop.err.orm.read-only-session-not-allow-update: 只读的session不支持修改操作
nop.err.orm.save-entity-not-transient: 当前实体状态为[{status}]，不允许保存。只有处于TRANSIENT状态的实体才允许保存
nop.err.orm.save-entity-replace-existing-entity: session中已经存在类型为[{entityName}]，主键为[{entityId}]的实体，不允许插入主键相同的实体
nop.err.orm.session-closed: session已关闭
nop.err.orm.session-not-run-on-context: ORM会话只能在单线程上访问，不支持并发访问
nop.err.orm.session.not-attached: 实体未与session关联，不能访问
nop.err.orm.sql-lib.convert-return-type-fail: 结果类型转换错误
nop.err.orm.sql-lib.invalid-col-index: sql语句的column配置的index必须在0和1000之间
nop.err.orm.sql-lib.invalid-sql-name: sqlName[{sqlName}]格式不合法，要求的格式为sqlLibName.sqlItemName
nop.err.orm.sql-lib.unknown-sql-item: sql库文件[{path}]中没有定义条目:{sqlItemName}
nop.err.orm.sql-param-count-mismatch: SQL语句的参数个数不正确，当前值:{count}，期待值:{expected}
nop.err.orm.tenant-id-not-allow-change: 租户ID不允许被改变
nop.err.orm.unknown-collection-persister: 未定义的集合持久化类:{collectionName}
nop.err.orm.unknown-compute-prop-arg: 对象[{entityName}]的计算属性[{propName}]不支持参数[{argName}]
nop.err.orm.unknown-entity-persister: 未定义的实体持久化类:{entityName}
nop.err.orm.unknown-fragment: 未知的SQL片段:{fragmentId}
nop.err.orm.unsupported-data-type: 不支持的数据类型:{dataType}
nop.err.orm.update-entity-multiple-rows: 更新实体[{entityName}:{entityId}]时发现多条重复记录
nop.err.orm.update-entity-not-found: 更新实体[{entityName}:{entityId}]失败，未找到匹配记录，可能是乐观锁更新失败
nop.err.orm.visit-loop-count-exceed-limit: 实体遍历循环的执行次数超过最大限制
nop.err.pom.reference-contains-loop: Maven不允许循环依赖
nop.err.proto.not-support-data-type: 不支持的类型:{dataType}
nop.err.record.aggregate-field-no-agg-func: 汇总字段没有设置aggFunc属性:{fieldName}
nop.err.record.case-value-map-to-unknown-type: 字段[{fieldName}]的条件类型映射到未定义的类型:{caseValue}=>{typeName}
nop.err.record.decode-length-is-too-long: length
nop.err.record.field-is-mandatory: 字段[{fieldName}]的值不允许为空
nop.err.record.field-length-greater-than-max-value: fieldName
nop.err.record.field-length-is-negative: 字段[{fieldName}]的长度为负数:{length}
nop.err.record.field-length-is-too-large: 字段[{fieldName}]的长度超过最大值:{length}
nop.err.record.field-length-is-too-small: 字段[{fieldName}]的长度小于最小值:{length}
nop.err.record.field-length-less-than-min-value: fieldName
nop.err.record.field-mapping-not-found: 未找到字段映射:{mappingName}
nop.err.record.field-not-collection-type: 字段[{fieldName}]的值不是合法的集合类型
nop.err.record.field-value-not-in-dict: 字段[{fieldName}]的值不在字典中:{value}
nop.err.record.invalid-flatten-list-field-name: 非法的列表字段名：{fieldName}。列表字段名格式为[fromName]-[index]-[subFieldName]
nop.err.record.list-duplicate-item: 字段[{fieldName}]的条目不允许重复:key={keyValue}
nop.err.record.mapping-not-found: 未找到映射:{mappingName}
nop.err.record.md-list-item-not-simple-value: 列表条目不是简单类型
nop.err.record.md-missing-field-not-optional: 缺少字段[{fieldName}]
nop.err.record.md-section-content-not-table: Markdown段落内容必须是表格:{content}
nop.err.record.md-section-not-allow-sub-section: Markdown段落不支持子段落
nop.err.record.no-enough-data: 缺少数据，无法读取
nop.err.record.no-enough-items: 仅读取[{readCount}]条数据，预计[{totalCount}]条
nop.err.record.no-match-for-case-value: 字段[{fieldName}]的条件类型没有找到匹配类型:{caseValue}
nop.err.record.no-switch-on-field: 条件类型无法确定类型值:{fieldName}
nop.err.record.not-enough-of-line: 不是换行符
nop.err.record.pos-not-in-cache: 位置{pos}不在缓存中
nop.err.record.type-no-fields: 结构体没有定义字段
nop.err.record.unknown-field: 未定义的字段：{fieldName}
nop.err.record.unknown-field-codec:{codec}: fieldName
nop.err.record.unknown-field-type: 未知的字段类型:{typeName}
nop.err.record.unknown-from-field: 未知的字段[{fieldName}]
nop.err.record.unknown-obj-type: 未知的对象类型:{typeName}
nop.err.record.unsupported-packet-field-length-field: '不支持的包长度字段长度:{lengthFieldLength}
  (期望: 1, 2, 3, 4, 或 8)'
nop.err.record.value-not-match-string: 值与预想的情况不匹配:pos={pos},expected={expected}
nop.err.rpc.cancelled: RPC调用已取消，原因:{reason}
nop.err.rpc.channel-closed: RPC连接已关闭
nop.err.rpc.empty-request: 请求对象为空
nop.err.rpc.flow-control-reject: RPC调用被限流
nop.err.rpc.flow-control.authority: 服务授权规则未通过
nop.err.rpc.flow-control.block: 系统繁忙，请求被限流
nop.err.rpc.flow-control.degrade: 服务降级限流
nop.err.rpc.flow-control.sys: 系统规则限流或降级
nop.err.rpc.handler-is-suspended: 消息处理处于暂停状态
nop.err.rpc.invalid-import-path: '无效的导入路径: {path}'
nop.err.rpc.invalid-message-topic: 非法的RPC消息主题：{topic}
nop.err.rpc.missing-service-header: 缺少nop-service参数
nop.err.rpc.no-handler: RPC服务没有找到合适的处理函数
nop.err.rpc.not-allow-method-overload: 服务[{serviceName}]的方法[{serviceMethod}]不支持函数重载
nop.err.rpc.not-allow-multiple-subscription: '不允许多次订阅消息主题: {topic}'
nop.err.rpc.not-allowed-service-name: 不支持的服务:{serviceName}
nop.err.rpc.request-args-count-mismatch: 服务方法[{serviceMethod}]的请求参数个数不匹配
nop.err.rpc.request-body-not-list: 请求对象的数据内容必须是列表类型
nop.err.rpc.timeout: RPC调用超时
nop.err.rpc.too-many-inflight-messages: 正在等待响应的RPC消息过多，超过最大限制[{maxWaitRequests}]
nop.err.rpc.unknown-service: 未定义的服务:{serviceName}
nop.err.rpc.unsupported-proto-version: '不支持的协议版本: {version}'
nop.err.schema.mandatory-prop-is-empty: 属性[{propName}]不能为空
nop.err.schema.obj-schema-no-prop: 对象没有定义名称为[{propName}]的属性
nop.err.schema.prop-convert-to-type-fail: 属性[{propName}]的值[{value}]不能转换为类型[{targetType}]
nop.err.schema.prop-length-greater-than-max-length: 属性[{propName}]的值[{value}]的长度超过最大值[{maxLength}]
nop.err.schema.prop-length-greater-than-utf8-length: 属性[{propName}]的值[{value}]的UTF8长度超过最大值[{maxLength}]
nop.err.schema.prop-length-less-than-min-length: 属性[{propName}]的值[{value}]的长度小于最小值[{maxLength}]
nop.err.schema.prop-not-match-pattern: 属性[{propName}]的值不满足格式要求
nop.err.schema.prop-value-not-collection: 属性[{propName}]的值不是集合类型
nop.err.schema.prop-value-not-in-dict: 属性[{propName}]的值[{value}]不在字典[{dictName}]定义中
nop.err.schema.prop-value-not-map: 属性[{propName}]的值不是Map类型
nop.err.schema.prop-value-too-large: 属性[{propName}]的值[{value}]大于最小值[{minValue}]
nop.err.schema.prop-value-too-small: 属性[{propName}]的值[{value}]小于最小值[{minValue}]
nop.err.schema.std-domain-validation-fail: 属性[{propName}]的值[{value}]不满足[{stdDomain}]格式要求
nop.err.script.compile-error: 脚本编译报错:{errMsg}
nop.err.shell.exec-command-fail: 执行命令行程序失败:{command}
nop.err.shell.exec-command-timeout: 执行命令行程序超时:command={command},超时时间为{timeout}
nop.err.shell.invalid-task-name: Shell任务的名称不能包含特殊字符，必须能对应到文件系统中的脚本文件:{taskName}
nop.err.shell.not-allow-change-file-perm: 不允许修改文件权限:{file}
nop.err.socket.accept-fail: 网络连接失败
nop.err.socket.connect-fail: 网络连接失败
nop.err.socket.read-fail: 网络读取数据失败
nop.err.socket.read-timeout: 读取数据超时
nop.err.socket.write-fail: 网络写数据失败
nop.err.sql.unknown-lib-path: sql库文件不存在:{path}
nop.err.task.cancelled: 任务已经被取消
nop.err.task.graph-no-active-step: 流程图[{stepPath}]已经没有活跃步骤，但是流程执行还没有结束
nop.err.task.graph-step-contains-loop: 流程图[{graphStepName}]包含循环结构，不满足要求，需要删除以下连接:{loopEdges}
nop.err.task.graph-step-no-enter-steps: 流程图[{stepName}]必须指定起始步骤
nop.err.task.graph-step-no-exit-steps: 流程图[{stepName}]必须指定终止步骤
nop.err.task.invalid-custom-type: 节点的扩展类型属性必须包含名字空间，例如customType='gpt:simple'
nop.err.task.loop-step-invalid-loop-var: 循环步骤的循环变量设置不正确：begin={begin},end={end},step={step}
nop.err.task.mandatory-input-not-allow-empty: 步骤[{stepPath}]的输入[{inputName}]不允许为空
nop.err.task.nop-persist-state-store: 没有定义持久化任务状态存储
nop.err.task.request-rate-exceed-limit: 访问速率超过限制：TPS={requestPerSecond}
nop.err.task.static-method-not-found: 类[{className}]中没有找到静态方法[{methodName}({argCount})]
nop.err.task.step-mandatory-output-is-empty: 步骤[{stepPath}]的输出[{output}]不允许为空
nop.err.task.step-timeout: 步骤已超时
nop.err.task.step.async-return-next-step-should-no-be-async: 异步步骤的返回结果不应为ASYNC标记
nop.err.task.step.not-restartable: 步骤[{stepName}]不允许多次执行
nop.err.task.step.null-async-promise: 异步步骤的线程局部变量[asyncPromise]不应该为null
nop.err.task.step.retry-times-exceed-limit: 步骤重试次数超过限制
nop.err.task.throttle-timeout: 任务[{taskName}]的步骤[{stepPath}]的限流等待超时
nop.err.task.unknown-next-step: 步骤[{stepPath}]不支持跳转到子步骤[{nextStep}]
nop.err.task.unknown-step-in-graph: 流程图[{graphStepName}]中没有定义步骤[{stepName}]
nop.err.task.unknown-step-in-lib: 任务库[{libName}]中没有定义步骤:[{stepName}]
nop.err.task.unknown-task-instance: 未知的任务实例:{taskInstanceId}
nop.err.task.unknown-wait-step: 步骤[{stepName}]等待的步骤[{waitStep}]没有定义
nop.err.task.unresolved-method-owner: 方法引用[{methodRef}]使用了未定义的类
nop.err.task.unsupported-step-type: 不支持节点[{stepName}]的类型:{stepType}
nop.err.tree.duplicate-node-id: 多个节点具有同样的id:{nodeId}
nop.err.vue.duplicate-component-name: '组件名称与已定义或者已导入的组件名重复: {componentName}'
nop.err.vue.invalid-node-type: 未定义的节点类型：{type}
nop.err.vue.slot-no-allow-slot-child: slot的子节点不允许再定义slot
nop.err.vue.template-no-slot-name: 模板没有通过v-slot:[name]指定slot名称
nop.err.vue.v-child-not-allow-attr: 以v:为前缀的子节点是属性的扩展表示方式，它本身不能再具有属性
nop.err.vue.v-child-not-allow-slot: 以v:为前缀的子节点是属性的扩展表示方式，它本身不能具有slot
nop.err.web.dynamic-file-missing-mock-block: 没有找到匹配的@enc-mock部分
nop.err.web.invalid-page-file-types: 请求路径[{path}]不是页面文件，文件后缀名必须是{allowedFileTypes}
nop.err.web.js-comment-not-end-properly: JS注释没有正确结束
nop.err.web.missing-resource: 资源文件[{path}]不存在
nop.err.web.page-not-allow-edit: 没有开启编辑模式，不允许编辑页面文件
nop.err.web.page-resource-not-file: 页面资源[{path}]不是文件，不允许修改
nop.err.web.unsupported-file-type: 请求路径[{path}]不是允许的文件类型，文件后缀名必须是{allowedFileTypes}
nop.err.xlang.break-statement-not-in-loop: break语句必须放到循环语句内部
nop.err.xlang.const-decl-no-initializer: 常量声明没有初始化表达式
nop.err.xlang.continue-statement-not-in-loop: break语句必须放到循环语句内部
nop.err.xlang.debugger-already-closed: 调试器已关闭
nop.err.xlang.declare-var-conflicts: 变量定义[{varName}]命名冲突，冲突位置为[{varDecl1}]和[{varDecl2}]
nop.err.xlang.duplicate-bean-class: 节点的beanClass定义重复:{beanClass}
nop.err.xlang.exec.arg-not-throwable: 表达式的执行结果不是Throwable类型:{expr}
nop.err.xlang.exec.array-binding-not-list: ArrayBinding表达式的返回值[{value}]不是List类型
nop.err.xlang.exec.array-not-allow-function: 数组类型不支持函数:{funcName}
nop.err.xlang.exec.call-func-fail: 调用函数失败
nop.err.xlang.exec.call-null-function: '函数表达式返回null，无法调用函数: {funcExpr}'
nop.err.xlang.exec.class-no-constructor: 类[{className}]上没有定义匹配的构造函数
nop.err.xlang.exec.class-no-static-field: 类[{className}]上没有定义静态属性[{propName}]
nop.err.xlang.exec.class-no-static-method: 类[{className}]上没有定义静态方法[{methodName}]或者参数个数不匹配
nop.err.xlang.exec.class-not-allow-attr-expr: 不允许在静态类上执行属性表达式:{className}
nop.err.xlang.exec.collect-result-not-single-node: c:collect标签设置了singleMode模式，但是具体执行得到的结果节点不是单节点
nop.err.xlang.exec.convert-func-only-allow-one-arg: 类型转换函数[{funcName}]只允许一个参数
nop.err.xlang.exec.expr-not-return-func: 表达式的返回结果不是函数类型:{funcExpr}
nop.err.xlang.exec.for-in-items-must-be-map: for-in语句的items表达式必须返回Map类型的对象
nop.err.xlang.exec.get-prop-on-null-obj: 对象表达式[{objExpr}]返回null，无法访问属性[{attrExpr}]
nop.err.xlang.exec.identifier-not-initialized: 变量[{varName}]没有初始化
nop.err.xlang.exec.inject-param-not-name-or-type: inject函数的参数必须是字符串或者Class类型
nop.err.xlang.exec.invalid-arg-count: 参数个数不正确：expected={expected}
nop.err.xlang.exec.invoke-function-fail: 调用函数失败
nop.err.xlang.exec.invoke-method-fail: 调用对象[{className}]上的方法[{funcName}]失败
nop.err.xlang.exec.log-message-not-static: log函数的第一个参数为消息模板，它不能为空
nop.err.xlang.exec.loop-step-must-not-be-zero: 循环的步长参数不能为0
nop.err.xlang.exec.make-prop-null: makeProperty的返回值不允许为空
nop.err.xlang.exec.make-prop-obj-null: makeProperty的对象为null
nop.err.xlang.exec.no-obj-method: 类型为[{className}]的对象上没有定义方法[{funcName}({argCount})]
nop.err.xlang.exec.not-literal-value: 表达式不是字面量，无法获取到静态值
nop.err.xlang.exec.not-readable-prop: 类[{className}]上的属性[{propName}]不是可读属性
nop.err.xlang.exec.not-supported-node: 不支持的语法节点
nop.err.xlang.exec.not-supported-operator: 不支持的运算符:{op}
nop.err.xlang.exec.not-writable-prop: 类[{className}]上的属性[{propName}]不是可写属性
nop.err.xlang.exec.obj-attr-is-null: 对象属性[{attrExpr}]的值为null
nop.err.xlang.exec.obj-prop-is-null: 对象属性[{propName}]的值为null
nop.err.xlang.exec.obj-unknown-method: 类[{className}]上没有找到对应的方法定义[{methodName}]或者参数个数不匹配
nop.err.xlang.exec.object-binding-not-map: ObjectBinding表达式的返回值[{value}]不是Map类型
nop.err.xlang.exec.program-should-not-use-external-closure-var: Program不应该使用外部闭包变量:{varName}
nop.err.xlang.exec.read-attr-expr-return-null: 属性表达式[{attrExpr}]的返回值不能为null
nop.err.xlang.exec.read-attr-fail: 访问对象[{className}]的属性[{attrValue}]失败
nop.err.xlang.exec.read-attr-not-string: 对象[{className}]上不支持属性[{attrValue}]失败
nop.err.xlang.exec.read-prop-fail: 访问对象[{className}]的属性[{propName}]失败
nop.err.xlang.exec.scope-var-is-undefined: scope变量[{varName}]没有定义
nop.err.xlang.exec.spread-item-not-map: 扩展表达式的返回值[{value}]不是Map类型
nop.err.xlang.exec.throw-exception: 抛出异常
nop.err.xlang.exec.throw-invalid-error: throw语句抛出的异常对象只能是异常码或者Throwable类型
nop.err.xlang.exec.throw-null-exception: throw语句的参数为null
nop.err.xlang.exec.too-few-args: 参数个数不足：minArgCount={minCount}
nop.err.xlang.exec.too-many-args: 参数个数超过限制：maxArgCount={maxCount}
nop.err.xlang.exec.unknown-prop: 类[{className}]上没有定义属性[{propName}]
nop.err.xlang.exec.unknown-static-field: 类[{className}]上没有定义静态属性[{propName}]
nop.err.xlang.exec.value-not-allow-empty: 值不允许为空
nop.err.xlang.exec.value-not-allow-null: 值不允许为null
nop.err.xlang.exec.write-attr-expr-return-null: 属性表达式[{attrExpr}]的返回值不能为null
nop.err.xlang.exec.write-attr-fail: 设置对象[{className}]的属性[{attrValue}]失败
nop.err.xlang.exec.write-prop-fail: 设置对象[{className}]的属性[{propName}]失败
nop.err.xlang.exec.write-prop-obj-null: 设置属性时对象不能为空
nop.err.xlang.exec.xml-ext-attrs-not-map: attrs表达式的返回值不是Map类型
nop.err.xlang.expr-not-json-value: 表达式不是JSON格式:{expr}
nop.err.xlang.expr-not-qualified-name: 表达式不是合法的名称:{expr}
nop.err.xlang.expr.binary-op-no-left-value: 二元操作符[{op}]没有有效的左侧表达式
nop.err.xlang.expr.binary-op-no-right-value: 二元操作符[{op}]没有有效的右侧表达式
nop.err.xlang.expr.empty-brace: 括号内表达式不能为空
nop.err.xlang.expr.filter-op-invalid-arg-count: 过滤运算符[{op}]的参数个数[{argCount}]不是{expected}
nop.err.xlang.expr.invalid-attr-expr: 解析属性表达式失败
nop.err.xlang.expr.json-literal-not-allow-prop-access: JSON字面量不允许直接直接访问属性
nop.err.xlang.expr.missing-factor: 表达式部分缺失
nop.err.xlang.expr.not-allow-cp-expr: 不支持编译期表达式
nop.err.xlang.expr.not-cp-expr: 只允许编译期表达式
nop.err.xlang.expr.not-end-properly: 解析失败，表达式没有正常结束
nop.err.xlang.expr.not-executable: 不是可执行的表达式
nop.err.xlang.expr.not-expected-op: 不是期望的运算符:{expected}
nop.err.xlang.expr.not-literal: 表达式必须返回固定值
nop.err.xlang.expr.not-single-expr: 只允许出现一个表达式，不允许文本和表达式混排，或者出现多个表达式
nop.err.xlang.expr.null-factor: 操作符[{op}]的子表达式不能为null
nop.err.xlang.expr.token-should-not-be-keyword: 变量名[{token}]不允许为关键字
nop.err.xlang.expr.unary-op-no-expr: 运算符[{op}]后没有合法的表达式
nop.err.xlang.expr.unexpected-char: 非法的字符
nop.err.xlang.expr.unsupported-op: 不支持的运算符:{op}
nop.err.xlang.expr.xpl-duplicate-attr-name: Xpl表达式的属性名重复
nop.err.xlang.filter.unknown-biz-var: 未定义的前缀引导语法变量:{varName}
nop.err.xlang.func-decl-conflict-with-global-func: 自定义函数[{funcName}]的名称与已经注册的全局函数名冲突
nop.err.xlang.func-decl-not-allow-prefix-g: 自定义函数[{funcName}]的名称不应该以g_为前缀，此前缀为全局函数保留
nop.err.xlang.global-var-not-allow-change: 全局变量不允许在脚本中通过赋值语句进行修改
nop.err.xlang.identifier-is-keyword: 标识符名称[{name}]不能是系统保留的关键字
nop.err.xlang.identifier-not-allow-change: 常量变量[{name}]不允许被修改
nop.err.xlang.identifier-not-function: 变量{varName}不是函数
nop.err.xlang.import-multiple-class-conflicts: 导入类[{class1}]和[{class2}]的别名都为{alias}，出现命名冲突
nop.err.xlang.import-multiple-lib-conflicts: 导入标签[{tag1}]和[{tag2}]时出现命名冲突
nop.err.xlang.imported-class-alias-is-built-in-type-name: 导入类的别名不允许是系统内置类型名称：{alias}
nop.err.xlang.imported-class-alias-must-starts-with-uppercase: 导入类的别名首字母必须大写
nop.err.xlang.initializer-only-allow-literal: 函数缺省值只允许字面量，不允许使用动态表达式
nop.err.xlang.invalid-method-ref: 非法的方法引用:{methodRef}
nop.err.xlang.invalid-parse-tree: 非法的解析树结构
nop.err.xlang.invalid-var-name: 不合法的变量名:{varName}
nop.err.xlang.java.not-support-class-type-parameter: 不支持定义泛型类:{className}
nop.err.xlang.java.type-alias-conflicted: 类型名称与导入的类名或者本文件中定义的其他类名冲突:{typeName}
nop.err.xlang.java.unsupported-element-value: 不支持的值类型:{value}
nop.err.xlang.javac.parse-fail: 解析java文件失败
nop.err.xlang.macro.func-arg-must-be-template-literal-or-string-literal: 模板宏函数的参数必须是模板文本类型或者文本类型
nop.err.xlang.macro.invalid-arg-ast: 宏函数的参数[{expr}]的类型不正确，期待类型为[{expectedType}]，实际类型为[{actualType}]
nop.err.xlang.param-name-conflicted: 参数名冲突:{paramName}
nop.err.xlang.scope-var-definition-conflicts: scope变量定义[{varName}]命名冲突，冲突位置为[{varDecl1}]和[{varDecl2}]
nop.err.xlang.template-expr-id-must-be-macro-function: 模板表达式的id必须是宏函数的函数名
nop.err.xlang.unresolved-identifier: 未定义的变量:{varName}
nop.err.xlang.unresolved-implicit-var: 未定义的隐式变量:{varName}
nop.err.xlang.unresolved-type: 未知的类型:{typeName}
nop.err.xlang.unsupported-op: 不支持的运算符:{op}
nop.err.xlang.use-var-before-declaration: 在变量定义前使用变量:{varName},定义位置:{declLoc},使用位置:{useLoc}
nop.err.xlang.var-decl-not-allow-binding: var变量声明不允许解构表达式
nop.err.xlang.xdef.attr-not-allow-override-ref: 属性[{attrName}]已经存在，不允许覆盖
nop.err.xlang.xdef.child-not-allow-override-ref: 子节点[{tagName}]已经存在，不允许覆盖
nop.err.xlang.xdef.child-not-support-extends: '本节点不支持x:extends设置:{node}，参见它的XDefNode定义:
  {xdefPath}'
nop.err.xlang.xdef.duplicate-child: 子节点名称不能重复
nop.err.xlang.xdef.duplicate-local-ref: xdef:name引用名称不能重复
nop.err.xlang.xdef.duplicate-node-id: xdef:id名称不能重复
nop.err.xlang.xdef.enum-value-not-in-options: 属性[{propName}]的值[{value}]不在选项列表[{options}]中
nop.err.xlang.xdef.fn-no-type-decl: '[{stdDomain}]缺少函数类型声明'
nop.err.xlang.xdef.illegal-body-value-for-std-domain: 节点[{tagName}]的内容不满足[{stdDomain}]格式要求
nop.err.xlang.xdef.illegal-class-name-for-enum-domain: '[className]不是合法的java类名'
nop.err.xlang.xdef.illegal-content-value-for-std-domain: 节点[{tagName}]的值[{value}]不满足[{stdDomain}]格式要求
nop.err.xlang.xdef.illegal-prop-value-for-std-domain: 属性[{propName}]的值[{value}]不满足[{stdDomain}]格式要求
nop.err.xlang.xdef.internal-ref-node-not-allow-attrs: xdef:ref为内部引用时，该节点不允许设置其他属性:{node}
nop.err.xlang.xdef.invalid-enum-value: 属性[{propName}]的值[{value}]不是合法的[{dictName}]枚举值
nop.err.xlang.xdef.keyed-list-must-assign-bean-body-type-explicitly: 节点对应KeyedList类型且具有多个子节点时必须明确指定xdef:bean-body-type属性
nop.err.xlang.xdef.list-no-child: 列表类型的节点没有定义元素类型
nop.err.xlang.xdef.list-node-not-allow-value: 集合节点不允许设置xdef:value
nop.err.xlang.xdef.map-no-child: Map类型的节点没有定义元素类型
nop.err.xlang.xdef.map-node-not-allow-value: Map节点不允许设置xdef:value
nop.err.xlang.xdef.no-bean-class-attr: xdef定义没有指定xdef:bean-class属性，不支持创建DslModel
nop.err.xlang.xdef.node-no-bean-class-attr: 对象节点需要x:bean-class属性来指定对象类名
nop.err.xlang.xdef.prop-not-allow-override: 属性[{propName}]已经存在，不允许覆盖
nop.err.xlang.xdef.ref-not-allow-circular-reference: xdef:ref不允许循环引用:{refName}
nop.err.xlang.xdef.ref-only-allow-on-obj-node: 只有对象节点允许设置xdef:ref属性。body-type不为空的节点可能映射到List/Map等结构，而不是对象类
nop.err.xlang.xdef.set-no-child: 集合类型的节点没有定义元素类型
nop.err.xlang.xdef.set-node-child-no-attr: 集合节点的子节点缺少指定的属性[{attrName}]
nop.err.xlang.xdef.set-node-must-has-key-attr: 标记为xdef:body-type=set的集合节点必须具有xdef:key-attr属性
nop.err.xlang.xdef.simple-node-not-allow-attr: 简单节点不允许包含属性
nop.err.xlang.xdef.std-domain-not-allow-node-content: '[{stdDomain}]不支持节点文本，只支持XML子节点配置'
nop.err.xlang.xdef.std-domain-not-support-options: '[{stdDomain}]不支持扩展选项'
nop.err.xlang.xdef.std-domain-not-support-prop: '[{stdDomain}]不支持属性设置，只支持XML节点配置'
nop.err.xlang.xdef.std-domain-not-support-xml-child: '[stdDomain]格式不支持XML子节点'
nop.err.xlang.xdef.tag-name-conflict-with-attr-name: 子节点名称不能与属性名重复:{tagName}
nop.err.xlang.xdef.union-element-type-is-unknown: union类型的元素必须具有确定的类型
nop.err.xlang.xdef.unique-attr-not-allow-on-xdef-any-tag: xdef:unique-attr属性不允许标注在xdef:any-tag标签上
nop.err.xlang.xdef.unique-attr-value-must-be-node-attr: xdef:unique-attr指定的名称[{attrName}]必须是节点的属性名
nop.err.xlang.xdef.unknown-definition-ref: xdef:ref定义未找到:{refName}
nop.err.xlang.xdef.unknown-std-domain: 未定义的stdDomain:{stdDomain}
nop.err.xlang.xdef.value-and-content-not-allow-both: xdef:value和节点内容表示同样的内容，不能同时设置
nop.err.xlang.xdsl.attr-not-allowed: 不允许的属性:{attrName}, 允许的名称为:{allowedNames}
nop.err.xlang.xdsl.attr-not-bean-prop: 属性[{attrName}]不是类[{className}]的属性
nop.err.xlang.xdsl.attr-not-valid-boolean: 属性[{attrName}]的值[{attrValue}]不是合法的布尔值,允许值true/false或者1/0
nop.err.xlang.xdsl.attr-not-valid-class-name: 属性[{attrName}]的值[{attrValue}]不是合法的java类名
nop.err.xlang.xdsl.attr-not-valid-def-type: 属性[{attrName}]的值[{attrValue}]不是合法的xdef类型定义
nop.err.xlang.xdsl.attr-not-valid-enum-value: 属性[{attrName}]的值[{attrValue}]不是合法的枚举值
nop.err.xlang.xdsl.attr-not-valid-generic-type: 属性[{attrName}]的值[{attrValue}]不是合法的类型定义
nop.err.xlang.xdsl.attr-not-valid-local-ref: 属性[{attrName}]的值[{attrValue}]不是合法的引用名称，它必须以@为前缀
nop.err.xlang.xdsl.attr-not-valid-prop-name: 属性[{attrName}]的值[{attrValue}]不是合法的java属性名
nop.err.xlang.xdsl.attr-not-valid-v-path: 属性[{attrName}]的值[{attrValue}]不是合法的虚拟文件路径
nop.err.xlang.xdsl.attr-not-valid-xml-name: 属性[{attrName}]的值[{attrValue}]不是合法的XML属性名或标签名
nop.err.xlang.xdsl.attr-value-is-empty: '[{tagName}]节点的属性[{attrName}]不允许为空'
nop.err.xlang.xdsl.config-child-must-be-import: x:config节点的内容必须是c:import标签，不允许其他标签
nop.err.xlang.xdsl.delta-node-not-inherit: 节点没有参与继承合并操作：{node}
nop.err.xlang.xdsl.final-node-not-allow-override: 已经标记为final的节点不允许被覆盖
nop.err.xlang.xdsl.invalid-override-attr: override属性的值不在XDefOverride常量类的定义范围内
nop.err.xlang.xdsl.missing-mandatory-child: 缺少必须的子节点[{tagName}]
nop.err.xlang.xdsl.model-no-name-attr: 模型对象没有name属性
nop.err.xlang.xdsl.multiple-node-has-same-unique-attr-value: 多个节点具有同样的唯一属性值:{attrName}={attrValue}
nop.err.xlang.xdsl.multiple-node-with-same-tag: 多个节点具有同样的标签名
nop.err.xlang.xdsl.no-schema: 必须通过x:schema属性来指定元模型
nop.err.xlang.xdsl.no-sub-schema-definition: 没有找到针对子类型[{subTypeValue}]的子对象定义
nop.err.xlang.xdsl.node-content-not-allow-empty: 节点内容不允许为空
nop.err.xlang.xdsl.node-duplicate-child: 节点的子节点名重复：{tagName}
nop.err.xlang.xdsl.node-duplicate-child-for-map: Map节点的子节点名重复：{tagName}
nop.err.xlang.xdsl.node-not-allow-content: 节点不允许具有文本内容
nop.err.xlang.xdsl.node-unexpected-tag-name: 节点名称为[{tagName}],期望的节点名称为[{expected}]
nop.err.xlang.xdsl.node-unique-key-value-not-allow-empty: 节点[{node}]的唯一键[{attrName}]不允许为空
nop.err.xlang.xdsl.not-allow-merge-between-node: 不允许两个节点之间定义合并操作，它们的合并算子不兼容
nop.err.xlang.xdsl.not-allow-multiple-super: 不允许存在多个x:super子节点
nop.err.xlang.xdsl.not-find-prototype-node: x:prototype属性所对应的节点不存在:{value}
nop.err.xlang.xdsl.not-find-super-node: 没有发现x:super子节点。merge-super和replace-super算子要求必须定义x:super子节点。
nop.err.xlang.xdsl.not-required-schema: x:schema属性所指定的schema[{schemaPath}]不是期待的[{requiredSchema}]
nop.err.xlang.xdsl.not-supported-schema-kind: 属性[{propName}]不支持schema类型[{schemaKind}]
nop.err.xlang.xdsl.prop-list-item-not-map: 属性[{propName}]的值应为对象结构，不允许空值
nop.err.xlang.xdsl.prop-no-sub-schema-definition: 属性[{propName}]的类型为union，但是没有找到针对子类型[{subTypeValue}]的子类型定义
nop.err.xlang.xdsl.prop-value-not-list: 属性[{propName}]的值[{value}]不是列表类型
nop.err.xlang.xdsl.prop-value-not-map: 属性[{propName}]的值[{value}]不是Map类型
nop.err.xlang.xdsl.run-extends-result-not-node: 执行x:extends的输出结果不是XNode类型
nop.err.xlang.xdsl.sub-type-prop-is-empty: 子类型属性[{subTypeProp}]的值不能为空
nop.err.xlang.xdsl.sub-type-prop-value-not-string: 属性[{propName}]的类型为union，它必须具有文本类型的、非空的子类型属性[{subTypeProp}]
nop.err.xlang.xdsl.super-extends-invalid-path: 当前节点路径不是虚拟文件路径，无法使用x:extends=super配置
nop.err.xlang.xdsl.super-extends-no-current-path: 当前节点没有资源路径，无法确定x:extends=super所对应的模型文件
nop.err.xlang.xdsl.super-node-not-allow-body: x:super子节点不允许存在内容
nop.err.xlang.xdsl.tag-name-not-allowed: 不允许的节点名称:{tagName}],允许的名称为:{allowedNames}
nop.err.xlang.xdsl.undefined-child-node: 在xdef模型[{xdefNodeName}]中未定义此节点:{tagName}
nop.err.xlang.xdsl.undefined-meta-cfg-var: 没有定义配置变量：{configVars}
nop.err.xlang.xdsl.unknown-prop: 未知属性:{propName}
nop.err.xlang.xdsl.value-not-valid-def-type: 值[{value}]不是合法的xdef类型定义
nop.err.xlang.xmeta.invalid-prop-meta-prop: propMeta的属性[{propName}]的值[{value}]格式不正确
nop.err.xlang.xmeta.only-allow-one-top-class: 每个元数据定义文件中仅允许一个顶层类
nop.err.xlang.xmeta.package-member-must-be-class: 元数据定义文件中只允许java类定义，不允许引入接口或者enum
nop.err.xlang.xmeta.schema-define-no-name-attr: schema定义没有name属性
nop.err.xlang.xmeta.union-schema-no-sub-type-prop: union schema的子节点必须具有xdef:bean-tag-prop属性，通过标签名来实现类型区分。或者在union节点上增加xdef:bean-sub-type-prop配置
nop.err.xlang.xmeta.unknown-ref: 未知的引用定义:{refName}
nop.err.xlang.xmeta.unknown-type: 未定义的类型:{typeName}
nop.err.xlang.xpath.root-not-allow-parent-selector: 根节点不支持父节点选择符
nop.err.xlang.xpath.unknown-operator: 未定义的XPath选择符:{op}
nop.err.xlang.xpl-expr-bracket-not-match: '#[和]必须一一对应'
nop.err.xlang.xpl-expr-invalid-mode: Lexer状态不正确
nop.err.xlang.xpl-expr-not-allow-nested: 标签表达式的参数只能是普通表达式，而不允许是标签表达式
nop.err.xlang.xpl-expr-paren-not-match: (和)必须一一对应
nop.err.xlang.xpl.assign-body-only-allow-field: 标签c:assign的body参数仅允许使用field设置表达式
nop.err.xlang.xpl.assign-duplicate-field: 标签c:assign的body参数不允许重复的field设置表达式
nop.err.xlang.xpl.assign-no-fields: 标签c:assign没有指定field设置表达式
nop.err.xlang.xpl.attr-must-not-be-sys-identifier: 非系统变量的变量名不能以$为前缀:{value}
nop.err.xlang.xpl.attr-not-allow-expr: 节点属性[{attrName}]不允许是表达式:{value}
nop.err.xlang.xpl.attr-not-cp-expr: 属性[{attrName}]的值不是编译期表达式
nop.err.xlang.xpl.attr-not-identifier: 节点属性不是合法的变量名
nop.err.xlang.xpl.attr-not-simple-expr: 节点属性[{attrName}]不是简单表达式，不需要使用${和}包裹:{value}
nop.err.xlang.xpl.attr-not-valid-class-name: 属性[{attrName}]的值[{attrValue}]不是合法的java类名
nop.err.xlang.xpl.attr-not-xml-name: 节点属性不是合法的XML名称
nop.err.xlang.xpl.attrs-expr-value-not-map: xpl:attrs的值必须是Map类型:{className}
nop.err.xlang.xpl.choose-child-not-conditional-expr: choose标签的子节点必须是条件表达式
nop.err.xlang.xpl.decorator-child-not-allow-multiple-decorated: decorator不允许多个decorated子节点
nop.err.xlang.xpl.decorator-child-not-allow-text-node: decorator不允许文本节点
nop.err.xlang.xpl.enum-no-factory-method: enum没有定义工厂方法
nop.err.xlang.xpl.eval-invalid-lang: eval节点的lang属性不合法：{lang}
nop.err.xlang.xpl.eval-not-allow-child: eval标签不允许包含子节点，只能是文本内容
nop.err.xlang.xpl.for-tag-not-allow-both-items-and-begin-end: for标签不允许同时定义items属性以及begin/end属性
nop.err.xlang.xpl.identifier-must-not-be-keyword: 变量名不能是XLang语言的关键字
nop.err.xlang.xpl.iif-node-child-count-not-two: c:iif节点的子节点个数必须是2
nop.err.xlang.xpl.import-from-and-class-both-null: import标签的from或者class属性必须不为空
nop.err.xlang.xpl.import-not-allow-both-lib-and-class-attr: import标签不允许同时存在from和class属性
nop.err.xlang.xpl.invalid-attr-expr: 属性表达式不合法：{attrName}
nop.err.xlang.xpl.invalid-lib-file-ext: 标签库文件的后缀名必须是xlib
nop.err.xlang.xpl.invalid-lib-namespace: 标签库文件名不是合法的名字空间
nop.err.xlang.xpl.invalid-lib-path: 非法的标签库路径
nop.err.xlang.xpl.invalid-type-ref: 非法的类型定义
nop.err.xlang.xpl.invalid-vpath-attr: 属性[attrName]的值[{value}]不是合法的虚拟路径
nop.err.xlang.xpl.log-tag-not-allow-child: log标签不允许包含子节点
nop.err.xlang.xpl.macro-tag-attr-not-static-value: 宏标签[{tagName}]的参数[{attrName}]必须是编译期可以确定的静态值
nop.err.xlang.xpl.missing-attr: 缺少必要的属性:{attrName}
nop.err.xlang.xpl.missing-slot: 缺少必要的子节点:{slotName}
nop.err.xlang.xpl.multiple-slot-with-same-name: 多个子节点名称重复:{tagName}
nop.err.xlang.xpl.not-allow-both-return-and-output-node: 不允许同时输出XNode节点和返回XNode节点
nop.err.xlang.xpl.not-allow-output: xpl的当前输出模式为[{outputMode}]，不允许输出文本内容
nop.err.xlang.xpl.not-allow-output-tag: xpl的当前为文本输出模式，不允许输出识别的XML节点
nop.err.xlang.xpl.not-allow-unknown-tag: 不允许使用未定义的标签:{tagName}
nop.err.xlang.xpl.not-custom-tag-func: 不是自定义的函数标签:{tagName}
nop.err.xlang.xpl.not-xml-name: 不是合法的XML名称:{value}
nop.err.xlang.xpl.only-allow-one-decorator-child: 不允许存在多个decorator子节点
nop.err.xlang.xpl.out-tag-not-allow-child: out标签不允许包含子节点
nop.err.xlang.xpl.parse-attr-int-fail: 解析整数类型属性失败:{attrName}={value}
nop.err.xlang.xpl.parse-attr-num-fail: 解析数字型属性失败:{attrName}={value}
nop.err.xlang.xpl.render-tag-only-in-tag-impl: xpl:slot属性仅能在标签定义内部被使用
nop.err.xlang.xpl.scope-args-must-be-map-expr: xpl:scopeBinding的内容必须是Map表达式
nop.err.xlang.xpl.script-not-allow-child: script标签不允许包含子节点，只能是文本内容
nop.err.xlang.xpl.tag-attr-is-mandatory: 标签[{tagName}]属性不允许为空:{attrName}
nop.err.xlang.xpl.tag-body-not-renderer: 标签[{tagName}]的slot参数[{slotName}]不是renderer类型
nop.err.xlang.xpl.tag-func-is-compiling: 标签[{tagName}]不支持编译期的嵌套调用，标签正在编译过程中，不允许被调用
nop.err.xlang.xpl.tag-func-too-many-args: 标签函数[{tagName}]的参数个数过多，最多允许[{maxCount}]个参数
nop.err.xlang.xpl.tag-missing-attr: 缺少必要的属性:{attrName}
nop.err.xlang.xpl.tag-missing-attrs: 标签缺少必要属性
nop.err.xlang.xpl.tag-missing-slot: 缺少必要的slot属性:{slotName}
nop.err.xlang.xpl.tag-no-body: 标签[{tagName}]没有声明body参数
nop.err.xlang.xpl.tag-no-implicit-attr: 标签[{tagName}]的隐式属性[{attrName}]为空，上下文中没有设置同名的变量
nop.err.xlang.xpl.unknown-filter-op: 未定义的判别算子：{op}
nop.err.xlang.xpl.unknown-lib-tag: 标签库[{libPath}]中没有定义标签[{tagName}]
nop.err.xlang.xpl.unknown-output-mode: 非法的XPL输出模式:{outputMode}
nop.err.xlang.xpl.unknown-script-lang: 未知的脚本语言:{lang},目前已注册的脚本语言有:{scriptLangs}
nop.err.xlang.xpl.unknown-slot-arg: slot[{slotName}]不支持变量[{argName}]
nop.err.xlang.xpl.unknown-tag-attr: 标签[{tagName}]不支持属性:{attrName},允许的属性为{allowedNames}
nop.err.xlang.xpl.unknown-tag-name: 未知的标签:{tagName}
nop.err.xlang.xpl.unknown-tag-slot: 未知的子节点:{slotName},允许的节点名为{allowedNames}
nop.err.xlsx.chart-color-resolve-fail: 解析图表颜色失败:colorName={colorName}
nop.err.xlsx.chart-parse-fail: 解析图表失败:chartId={chartId},partName={partName}
nop.err.xlsx.chart-style-parse-fail: 解析图表样式失败:parserName={parserName},elementName={elementName}
nop.err.xlsx.chart-theme-load-fail: 加载图表主题失败:partName={partName}
nop.err.xlsx.null-package: ExcelOfficePackage不能为null
nop.err.xlsx.null-rel-part: 没有关联文件:type={type},relId={relId}
nop.err.xlsx.unknown-sheet-name: 找不到sheet名称为:{sheetName}
nop.err.xpl.invalid-xml-name: 不允许输出非法的XML名称:{name}
nop.err.xpl.this-lib-ns-only-allowed-in-tag-impl: thisLib名字空间仅能在表现的实现代码中使用
nop.err.xpl.xlib.node-slot-not-support-arg: bodyType为node的slot不支持arg配置
nop.err.xpl.xlib.not-allow-named-slot-if-default-is-used: 如果定义了名为default的slot，则不能再定义其他slot
nop.err.xpl.xlib.slot-name-conflict-with-attr-name: slot的变量名[slotName]与标签属性名[attrName]冲突
nop.err.xpl.xlib.tag-no-source-defined: 标签库没有定义内嵌的source实现，也没有外部关联的[{resourceName}]实现文件
nop.err.xpl.xlib.unknown-tag: 在标签库[{libPath}]中没有定义标签[{tagName}]
nop.err.xpt.cell-expr-ds-name: '单元格展开表达式中必须具有ds定义，格式为^dsName!fieldName: {expr}'
nop.err.xpt.cell-expr-result-not-one-cell: 表达式[{expr}]返回单元格个数为[{size}]，不是单个单元格
nop.err.xpt.invalid-cell-range-expr: 非法的单元格区间表达式
nop.err.xpt.invalid-ds-name: 非法的数据源名称
nop.err.xpt.invalid-excel-formula: 非法的Excel公式:{source}
nop.err.xpt.invalid-field-name: 非法的字段名
nop.err.xpt.invalid-image-data: 图片数据不是字节数组或者IResource对象
nop.err.xpt.invalid-row-parent: 表格[{sheetName}]的单元格[{cellPos}]的列父格[{colParent}]必须配置为列展开
nop.err.xpt.missing-var-ds: 未定义单元格变量cell
nop.err.xpt.not-support-expr-in-formula: Excel公式中不支持表达式:{expr}
nop.err.xpt.row-parent-contains-loop: 表格[{sheetName}]的单元格[{cellPos}]的行父格[{colParent}]不能包含循环指向，必须构成树状结构
nop.err.xpt.undefined-cell-model-prop: 未定义的单元格模型的属性[{propName}]
nop.err.xpt.undefined-chart-model-prop: 未定义的图表模型的属性[{propName}]
nop.err.xpt.undefined-image-model-prop: 未定义的图片模型的属性[{propName}]
nop.err.xpt.unknown-report-model: 未知的报表模型：{reportName}
nop.err.xpt.unsupported-render-type: 不支持的报表输出类型：{renderType}
nop.err.xpt.unsupported-xpt-file-type: 不支持的报表文件后缀:{fileType}，允许的文件后缀名为:{allowedFileTypes}
nop.err.xui.form.cell-not-prop: 表单[{formId}]的字段[{cellId}]不是已定义的实体属性
nop.err.xui.form.cell.unknown-depend: 表单[{formId}]的字段[{cellId}]依赖了未定义的对象属性[{propName}]
nop.err.xui.form.unknown-prop: 表单[{formId}]引用了未定义的对象属性[{propName}]
nop.err.xui.grid.col-not-prop: 表格[{gridId}]的列[{colId}]不是已定义的实体属性
nop.err.xui.grid.col-unknown-depend: 表格[{gridId}]的字段[{colId}]依赖了未定义的对象属性[{propName}]
nop.err.xui.invalid-relation: 属性[{propName}]的ext:relation关联设置错误
nop.err.xui.ref-view-must-has-page-or-grid-or-form-attr: view配置必须指定page、form或者grid属性之一
nop.err.xui.ref-view-not-exists: view配置不存在：{viewPath}
nop.err.xui.ref-view-page-grid-form-only-allow-one-non-empty: view配置的page、form、grid属性只允许有一个非空，不能设置多个
nop.err.xui.unknown-form: 未定义的表单:{formId}
nop.err.xui.unknown-json-component-prop: 没有找到对应的json组件属性:{propName}
nop.xui.unknown-grid: 未定义的表格:{gridId}
nop.xui.unknown-page: 未定义的页面:{pageId}
